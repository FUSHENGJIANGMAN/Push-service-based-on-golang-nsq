<!doctype html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8" />
    <title>æ¶ˆæ¯å‘é€ä¸­å¿ƒ</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        /* æ—‹è½¬åŠ¨ç”» */
        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        :root {
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
        }

        body {
            margin: 0;
            background: #0b1020;
            color: #e8ecff;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #ffffff;
            margin: 0 0 10px 0;
            font-size: 28px;
            font-weight: 600;
        }

        .header p {
            color: #a7b0d5;
            margin: 0;
            font-size: 16px;
        }

        .main-content {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 30px;
            align-items: start;
        }

        .sidebar {
            background: linear-gradient(180deg, rgba(20, 30, 70, .3), rgba(10, 15, 35, .4));
            border: 1px solid #24315f;
            border-radius: 14px;
            padding: 20px;
            position: sticky;
            top: 20px;
        }

        .sidebar h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
            color: #ffffff;
            border-bottom: 1px solid #24315f;
            padding-bottom: 10px;
        }

        .message-types {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .type-button {
            background: rgba(36, 49, 95, 0.4);
            border: 1px solid #24315f;
            border-radius: 8px;
            padding: 12px 16px;
            color: #e8ecff;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
            font-size: 14px;
        }

        .type-button:hover {
            background: rgba(52, 66, 111, 0.6);
            border-color: #34426f;
        }

        .type-button.active {
            background: linear-gradient(135deg, #4c6ef5, #3b5bdb);
            border-color: #4c6ef5;
            color: #ffffff;
        }

        .channels-section {
            margin-top: 25px;
            padding-top: 20px;
            border-top: 1px solid #24315f;
        }

        .channels-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .channel-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: rgba(36, 49, 95, 0.2);
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .channel-checkbox:hover {
            background: rgba(36, 49, 95, 0.4);
        }

        .channel-checkbox input {
            margin: 0;
        }

        .channel-checkbox label {
            font-size: 13px;
            cursor: pointer;
            flex: 1;
        }

        .form-container {
            background: linear-gradient(180deg, rgba(20, 30, 70, .3), rgba(10, 15, 35, .4));
            border: 1px solid #24315f;
            border-radius: 14px;
            padding: 30px;
        }

        .form-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid #24315f;
        }

        .form-title {
            font-size: 20px;
            font-weight: 600;
            color: #ffffff;
            margin: 0;
        }

        .form-fields {
            display: grid;
            gap: 20px;
            margin-bottom: 30px;
        }

        .field-group {
            display: grid;
            gap: 8px;
        }

        .field-label {
            font-size: 14px;
            font-weight: 500;
            color: #a7b0d5;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .field-label .required {
            color: #ff6b6b;
            font-size: 12px;
        }

        .field-description {
            font-size: 12px;
            color: #7c8db5;
            margin-top: 2px;
        }

        /* å‘é€çŠ¶æ€æ ·å¼ */
        .status-section {
            background: linear-gradient(180deg, rgba(20, 30, 70, .3), rgba(10, 15, 35, .4));
            border: 1px solid #24315f;
            border-radius: 12px;
            padding: 15px;
            overflow-x: auto;
            min-width: 350px;
        }

        .status-section h4 {
            margin: 0 0 10px 0;
            font-size: 16px;
            font-weight: 600;
        }

        .channel-status {
            display: inline-flex;
            align-items: center;
            justify-content: flex-start;
            padding: 8px 12px;
            margin: 5px 8px 5px 0;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.05);
            min-width: 200px;
            max-width: none;
            width: auto;
            white-space: nowrap;
            flex-shrink: 0;
            gap: 8px;
        }

        .channel-status.success {
            background: rgba(34, 197, 94, 0.1);
            border-left: 3px solid #22c55e;
        }

        .channel-status.error {
            background: rgba(239, 68, 68, 0.1);
            border-left: 3px solid #ef4444;
        }

        .channel-status.pending {
            background: rgba(251, 191, 36, 0.1);
            border-left: 3px solid #fbbf24;
        }

        /* å“åº”å¼çŠ¶æ€æ˜¾ç¤º */
        @media (max-width: 768px) {
            #sendingStatusDisplay>div {
                flex-direction: column !important;
            }

            .status-section {
                min-width: auto !important;
                margin-bottom: 15px;
            }
        }

        @media (max-width: 1200px) {
            .status-section {
                min-width: 250px;
            }
        }

        .field-input {
            background: rgba(11, 16, 32, 0.8);
            border: 1px solid #24315f;
            border-radius: 8px;
            padding: 12px 16px;
            color: #e8ecff;
            font-size: 14px;
            transition: border-color 0.2s ease;
        }

        .field-input:focus {
            outline: none;
            border-color: #4c6ef5;
            box-shadow: 0 0 0 2px rgba(76, 110, 245, 0.1);
        }

        .field-input::placeholder {
            color: #6c7b95;
        }

        textarea.field-input {
            min-height: 80px;
            resize: vertical;
            font-family: inherit;
        }

        .array-field {
            background: rgba(11, 16, 32, 0.6);
            border: 1px solid #24315f;
            border-radius: 8px;
            padding: 16px;
        }

        .array-items {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 12px;
        }

        .array-item {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .array-item input {
            flex: 1;
        }

        .array-remove {
            background: #e03131;
            border: none;
            border-radius: 4px;
            color: white;
            padding: 8px 12px;
            cursor: pointer;
            font-size: 12px;
        }

        .array-add {
            background: #37b24d;
            border: none;
            border-radius: 6px;
            color: white;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
        }

        .object-field {
            background: rgba(11, 16, 32, 0.6);
            border: 1px solid #24315f;
            border-radius: 8px;
            padding: 16px;
        }

        .object-field textarea {
            width: 100%;
            min-height: 120px;
            background: rgba(11, 16, 32, 0.8);
            border: 1px solid #24315f;
            border-radius: 6px;
            padding: 12px;
            color: #e8ecff;
        }

        /* é™„ä»¶ä¸Šä¼ æ ·å¼ */
        .attachment-field {
            margin-bottom: 20px;
        }

        .attachment-upload-area {
            margin-bottom: 15px;
        }

        .upload-zone {
            border: 2px dashed #4c6ef5;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: rgba(76, 110, 245, 0.05);
            position: relative;
        }

        .upload-zone:hover {
            border-color: #364fc7;
            background: rgba(76, 110, 245, 0.1);
        }

        .upload-zone.drag-over {
            border-color: #22c55e;
            background: rgba(34, 197, 94, 0.1);
        }

        .upload-icon {
            font-size: 48px;
            margin-bottom: 15px;
        }

        .upload-text p {
            margin: 5px 0;
            color: #8899bb;
        }

        .upload-hint {
            font-size: 14px;
            color: #6b7894;
        }

        .file-input {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        .attachment-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .attachment-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            border: 1px solid #374151;
            border-radius: 6px;
            margin-bottom: 8px;
            background: rgba(55, 65, 81, 0.3);
        }

        .attachment-info {
            display: flex;
            align-items: center;
            flex: 1;
        }

        .file-icon {
            font-size: 24px;
            margin-right: 12px;
        }

        .file-details {
            flex: 1;
        }

        .file-name {
            font-weight: 500;
            color: #e8ecff;
            margin-bottom: 4px;
        }

        .file-meta {
            font-size: 12px;
            color: #8899bb;
        }

        .attachment-actions {
            display: flex;
            gap: 8px;
        }

        .btn-download,
        .btn-remove {
            background: none;
            border: 1px solid #4c6ef5;
            color: #4c6ef5;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .btn-download:hover {
            background: #4c6ef5;
            color: white;
        }

        .btn-remove {
            border-color: #e03131;
            color: #e03131;
        }

        .btn-remove:hover {
            background: #e03131;
            color: white;
        }

        .attachment-progress {
            padding: 12px;
            border: 1px solid #374151;
            border-radius: 6px;
            margin-bottom: 8px;
            background: rgba(55, 65, 81, 0.3);
        }

        .progress-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: #374151;
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #4c6ef5;
            transition: width 0.3s ease;
        }

        .progress-status {
            font-size: 12px;
            color: #8899bb;
        }

        .actions {
            display: flex;
            gap: 15px;
            justify-content: flex-end;
            padding-top: 20px;
            border-top: 1px solid #24315f;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: linear-gradient(135deg, #4c6ef5, #3b5bdb);
            color: white;
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #3b5bdb, #2f4fb3);
        }

        .btn-secondary {
            background: rgba(36, 49, 95, 0.6);
            color: #e8ecff;
            border: 1px solid #24315f;
        }

        .btn-secondary:hover {
            background: rgba(52, 66, 111, 0.8);
        }

        .btn-outline {
            background: transparent;
            color: #4c6ef5;
            border: 1px solid #4c6ef5;
        }

        .btn-outline:hover {
            background: rgba(76, 110, 245, 0.1);
        }

        .loading {
            opacity: 0.6;
            pointer-events: none;
        }

        .success-message,
        .error-message {
            padding: 12px 16px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 14px;
        }

        .success-message {
            background: rgba(55, 178, 77, 0.1);
            border: 1px solid #37b24d;
            color: #51cf66;
        }

        .error-message {
            background: rgba(224, 49, 49, 0.1);
            border: 1px solid #e03131;
            color: #ff6b6b;
        }

        /* æ¥æ”¶è€…ä¿¡æ¯åŒºåŸŸæ ·å¼ */
        .recipients-section {
            margin-top: 30px;
            padding: 20px;
            background: rgba(36, 49, 95, 0.3);
            border-radius: 12px;
            border: 1px solid #24315f;
        }

        .recipients-section h3 {
            color: #ffffff;
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 15px;
        }

        .recipient-group {
            margin-bottom: 20px;
        }

        .recipient-group:last-child {
            margin-bottom: 0;
        }

        .recipient-channel-label {
            color: #a7b0d5;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .recipient-channel-label .channel-icon {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            display: inline-block;
        }

        .channel-icon.web {
            background: #4c6ef5;
        }

        .channel-icon.email {
            background: #f59f00;
        }

        .channel-icon.sms {
            background: #51cf66;
        }

        .channel-icon.voice {
            background: #ff6b6b;
        }

        .recipient-input-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .recipient-input {
            background: rgba(11, 16, 32, 0.8);
            border: 1px solid #24315f;
            border-radius: 8px;
            padding: 10px 14px;
            color: #e8ecff;
            font-size: 14px;
            transition: border-color 0.2s ease;
        }

        .recipient-input:focus {
            outline: none;
            border-color: #4c6ef5;
            box-shadow: 0 0 0 3px rgba(76, 110, 245, 0.1);
        }

        .recipient-input::placeholder {
            color: #7c8db5;
        }

        .recipient-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 8px;
        }

        .recipient-tag {
            background: rgba(76, 110, 245, 0.2);
            color: #4c6ef5;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 4px;
            border: 1px solid transparent;
            transition: all 0.2s ease;
        }

        .recipient-tag.invalid {
            background: rgba(224, 49, 49, 0.2);
            color: #ff6b6b;
            border-color: #ff6b6b;
        }

        .recipient-tag .remove-tag {
            cursor: pointer;
            color: #ff6b6b;
            font-weight: bold;
        }

        .recipient-tag .remove-tag:hover {
            color: #e03131;
        }

        /* æ·»åŠ é€šé“çŠ¶æ€æŒ‡ç¤ºå™¨ */
        .channel-status {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-left: 8px;
        }

        .channel-status.valid {
            background: #51cf66;
        }

        .channel-status.invalid {
            background: #ff6b6b;
        }

        .channel-status.empty {
            background: #868e96;
        }

        .help-text {
            font-size: 12px;
            color: #7c8db5;
            margin-top: 4px;
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .sidebar {
                position: static;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .channels-grid {
                grid-template-columns: 1fr;
            }

            .actions {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }
        }

        /* JSONç¼–è¾‘å™¨ç¾åŒ– */
        .json-editor {
            position: relative;
        }

        .json-editor .field-input {
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
        }

        .json-preview {
            background: rgba(11, 16, 32, 0.9);
            border: 1px solid #24315f;
            border-radius: 8px;
            padding: 16px;
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
        }

        .json-preview pre {
            margin: 0;
            color: #a7b0d5;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            line-height: 1.4;
        }

        /* çŠ¶æ€æŒ‡ç¤ºå™¨ */
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-success {
            background: #37b24d;
        }

        .status-error {
            background: #e03131;
        }

        .status-warning {
            background: #f59f00;
        }

        .status-info {
            background: #4c6ef5;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>æ¶ˆæ¯å‘é€ä¸­å¿ƒ</h1>
            <p>æ”¯æŒå¤šç§æ¶ˆæ¯ç±»å‹å’Œä¼ è¾“é€šé“çš„ç»Ÿä¸€å‘é€å¹³å°</p>
        </div>

        <div class="main-content">
            <div class="sidebar">
                <h3>æ¶ˆæ¯ç±»å‹</h3>
                <div class="message-types" id="messageTypes">
                    <!-- åŠ¨æ€åŠ è½½æ¶ˆæ¯ç±»å‹ -->
                </div>

                <div class="channels-section">
                    <h3>å‘é€é€šé“</h3>
                    <div class="channels-grid">
                        <div class="channel-checkbox">
                            <input type="checkbox" id="channel-web" value="web" checked>
                            <label for="channel-web">ç«™å†…ä¿¡</label>
                        </div>
                        <div class="channel-checkbox">
                            <input type="checkbox" id="channel-email" value="email">
                            <label for="channel-email">é‚®ä»¶</label>
                        </div>
                        <div class="channel-checkbox">
                            <input type="checkbox" id="channel-sms" value="sms">
                            <label for="channel-sms">çŸ­ä¿¡</label>
                        </div>
                        <div class="channel-checkbox">
                            <input type="checkbox" id="channel-voice" value="voice">
                            <label for="channel-voice">è¯­éŸ³</label>
                        </div>
                    </div>
                </div>

                <div class="recipients-section" id="recipientsSection">
                    <h3>æ¥æ”¶è€…ä¿¡æ¯</h3>
                    <div class="recipients-content" id="recipientsContent">
                        <!-- åŠ¨æ€ç”Ÿæˆä¸åŒé€šé“çš„æ¥æ”¶è€…è¾“å…¥å­—æ®µ -->
                    </div>
                </div>
            </div>

            <div class="form-container">
                <div class="form-header">
                    <h2 class="form-title" id="formTitle">é€‰æ‹©æ¶ˆæ¯ç±»å‹</h2>
                    <div class="actions" style="margin: 0; padding: 0; border: none;">
                        <div class="reset-button-group" style="position: relative; display: inline-block;">
                            <button class="btn btn-outline" onclick="resetForm()">é‡ç½®è¡¨å•</button>
                            <button class="btn btn-outline" onclick="showResetOptions()" title="é‡ç½®é€‰é¡¹"
                                style="margin-left: 8px; padding: 10px 12px;">âš™ï¸</button>
                            <div id="resetOptions"
                                style="display: none; position: absolute; top: 100%; right: 0; background: #1a1f3a; border: 1px solid #24315f; border-radius: 6px; z-index: 1000; min-width: 200px; box-shadow: 0 4px 12px rgba(0,0,0,0.3);">
                                <button onclick="resetForm(false); hideResetOptions();"
                                    style="display: block; width: 100%; padding: 10px 15px; background: none; border: none; color: #e8ecff; text-align: left; cursor: pointer; border-bottom: 1px solid #24315f;">ä»…é‡ç½®è¡¨å•</button>
                                <button onclick="resetForm(true); hideResetOptions();"
                                    style="display: block; width: 100%; padding: 10px 15px; background: none; border: none; color: #e8ecff; text-align: left; cursor: pointer;">é‡ç½®è¡¨å•å’ŒçŠ¶æ€å†å²</button>
                            </div>
                        </div>
                        <button class="btn btn-secondary" onclick="previewMessage()">é¢„è§ˆ</button>
                    </div>
                </div>

                <div id="messageDisplay" style="display: none;">
                    <!-- æˆåŠŸ/é”™è¯¯æ¶ˆæ¯æ˜¾ç¤ºåŒºåŸŸ -->
                </div> <!-- ç‹¬ç«‹çš„å‘é€çŠ¶æ€æ˜¾ç¤ºåŒºåŸŸ - æ¨ªå‘å¸ƒå±€ -->
                <div id="sendingStatusDisplay" style="display: none; margin-bottom: 20px; position: relative;">
                    <!-- å…³é—­æŒ‰é’® -->
                    <button onclick="closeSendingStatus()"
                        style="position: absolute; top: 5px; right: 5px; background: rgba(239, 68, 68, 0.8); color: white; border: none; border-radius: 50%; width: 24px; height: 24px; cursor: pointer; font-size: 12px; z-index: 10;"
                        title="å…³é—­çŠ¶æ€æ˜¾ç¤º">Ã—</button>

                    <div style="display: flex; gap: 20px; flex-wrap: wrap;">
                        <!-- é€šç”¨æ¶ˆæ¯å‘é€çŠ¶æ€ -->
                        <div id="generalSendingStatus" class="status-section"
                            style="display: none; flex: 1; min-width: 300px;">
                            <h4 style="color: #ffffff; margin-bottom: 10px;">ğŸ“§ é€šç”¨æ¶ˆæ¯å‘é€çŠ¶æ€</h4>
                            <div id="generalStatusContent"></div>
                        </div>

                        <!-- è¯­éŸ³æ¶ˆæ¯å‘é€çŠ¶æ€ -->
                        <div id="voiceSendingStatus" class="status-section"
                            style="display: none; flex: 1; min-width: 300px;">
                            <h4 style="color: #40e0d0; margin-bottom: 10px;">ğŸ¤ è¯­éŸ³æ¶ˆæ¯å‘é€çŠ¶æ€</h4>
                            <div id="voiceStatusContent"></div>
                        </div>

                        <!-- çŸ­ä¿¡æ¶ˆæ¯å‘é€çŠ¶æ€ -->
                        <div id="smsSendingStatus" class="status-section"
                            style="display: none; flex: 1; min-width: 300px;">
                            <h4 style="color: #ffa500; margin-bottom: 10px;">ğŸ’¬ çŸ­ä¿¡æ¶ˆæ¯å‘é€çŠ¶æ€</h4>
                            <div id="smsStatusContent"></div>
                        </div>
                    </div>
                </div>

                <div id="formContent">
                    <div style="text-align: center; padding: 40px; color: #7c8db5;">
                        <p>è¯·åœ¨å·¦ä¾§é€‰æ‹©è¦å‘é€çš„æ¶ˆæ¯ç±»å‹</p>
                    </div>
                </div>

                <div class="actions" id="formActions" style="display: none;">
                    <button class="btn btn-secondary" onclick="saveDraft()">ä¿å­˜è‰ç¨¿</button>
                    <button class="btn btn-primary" onclick="sendMessage()">å‘é€æ¶ˆæ¯</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let messageFormats = {};
        let currentMessageType = '';
        let selectedChannels = ['web'];

        // é€šé“çŠ¶æ€è·Ÿè¸ª - å®ç°ç‹¬ç«‹çŠ¶æ€æ›´æ–°å’ŒæŒä¹…åŒ–
        let channelStatusTracker = {
            channels: {}, // { channelName: { status: 'pending|success|failed', message: '', timestamp: number } }
            isTracking: false,
            messageType: '', // æ·»åŠ æ¶ˆæ¯ç±»å‹è·Ÿè¸ª
            statusHistory: {}, // çŠ¶æ€å†å²ç¼“å­˜ { messageType: { channels: {}, isTracking: bool, timestamp: number } }

            // åˆå§‹åŒ–è·Ÿè¸ª
            startTracking: function (channels, messageType) {
                this.isTracking = true;
                this.messageType = messageType || currentMessageType;
                this.channels = {};
                channels.forEach(channel => {
                    this.channels[channel] = {
                        status: 'pending',
                        message: 'å‘é€ä¸­...',
                        timestamp: Date.now()
                    };
                });

                // ç¼“å­˜å½“å‰çŠ¶æ€
                this.saveStatusToHistory();
            },

            // ä¿å­˜çŠ¶æ€åˆ°å†å²è®°å½•
            saveStatusToHistory: function () {
                if (this.messageType) {
                    this.statusHistory[this.messageType] = {
                        channels: JSON.parse(JSON.stringify(this.channels)), // æ·±æ‹·è´
                        isTracking: this.isTracking,
                        timestamp: Date.now()
                    };
                }
            },

            // ä»å†å²è®°å½•æ¢å¤çŠ¶æ€
            restoreStatusFromHistory: function (messageType) {
                const history = this.statusHistory[messageType];
                if (history && history.channels && Object.keys(history.channels).length > 0) {
                    // æ£€æŸ¥å†å²çŠ¶æ€æ˜¯å¦è¿˜æ˜¯æœ‰æ•ˆçš„ï¼ˆä¸è¶…è¿‡30åˆ†é’Ÿï¼‰
                    const isRecentHistory = (Date.now() - history.timestamp) < 30 * 60 * 1000;

                    if (isRecentHistory) {
                        this.channels = JSON.parse(JSON.stringify(history.channels)); // æ·±æ‹·è´
                        this.isTracking = history.isTracking;
                        this.messageType = messageType;

                        // æ˜¾ç¤ºæ¢å¤çš„çŠ¶æ€
                        this.showRestoredStatus();
                        return true;
                    } else {
                        // æ¸…é™¤è¿‡æœŸçš„å†å²è®°å½•
                        delete this.statusHistory[messageType];
                    }
                }
                return false;
            },

            // æ˜¾ç¤ºæ¢å¤çš„çŠ¶æ€
            showRestoredStatus: function () {
                if (!this.isCurrentMessageType() || Object.keys(this.channels).length === 0) {
                    return;
                }

                // æ˜¾ç¤ºçŠ¶æ€å®¹å™¨
                const container = document.getElementById('sendingStatusDisplay');
                if (container) {
                    container.style.display = 'block';
                }

                // æŒ‰åˆ†ç±»æ˜¾ç¤ºçŠ¶æ€
                const categories = ['general', 'voice', 'sms'];
                categories.forEach(category => {
                    const categoryChannels = Object.keys(this.channels).filter(channel =>
                        getChannelCategory(channel) === category
                    );

                    if (categoryChannels.length > 0) {
                        const statusSection = document.getElementById(`${category}SendingStatus`);
                        if (statusSection) {
                            statusSection.style.display = 'block';
                        }
                        this.renderCategoryStatus(category);
                    }
                });
            },

            // æ£€æŸ¥æ˜¯å¦æ˜¯å½“å‰æ¶ˆæ¯ç±»å‹
            isCurrentMessageType: function () {
                return this.messageType === currentMessageType;
            },

            // æ›´æ–°å•ä¸ªé€šé“çŠ¶æ€
            updateChannel: function (channel, status, message = '', error = '') {
                if (this.channels[channel] && this.isCurrentMessageType()) {
                    this.channels[channel] = {
                        status: status,
                        message: message || (status === 'success' ? 'å‘é€æˆåŠŸ' : status === 'failed' ? 'å‘é€å¤±è´¥' : 'å‘é€ä¸­...'),
                        error: error,
                        timestamp: Date.now()
                    };

                    // ç«‹å³æ›´æ–°UIæ˜¾ç¤º
                    this.updateChannelUI(channel);

                    // ä¿å­˜çŠ¶æ€åˆ°å†å²è®°å½•
                    this.saveStatusToHistory();
                }
            },

            // æ›´æ–°ç‰¹å®šé€šé“çš„UI
            updateChannelUI: function (channel) {
                if (!this.isCurrentMessageType()) {
                    return; // ä¸æ˜¯å½“å‰æ¶ˆæ¯ç±»å‹ï¼Œä¸æ›´æ–°UI
                }

                const category = getChannelCategory(channel);
                const statusContent = document.getElementById(`${category}StatusContent`);

                if (statusContent) {
                    // é‡æ–°æ¸²æŸ“è¯¥åˆ†ç±»ä¸‹æ‰€æœ‰é€šé“çš„çŠ¶æ€
                    this.renderCategoryStatus(category);
                }
            },

            // æ¸²æŸ“åˆ†ç±»çŠ¶æ€
            renderCategoryStatus: function (category) {
                if (!this.isCurrentMessageType()) {
                    return; // ä¸æ˜¯å½“å‰æ¶ˆæ¯ç±»å‹ï¼Œä¸æ¸²æŸ“
                }

                const statusContent = document.getElementById(`${category}StatusContent`);
                if (!statusContent) return;

                // è·å–è¯¥åˆ†ç±»ä¸‹çš„æ‰€æœ‰é€šé“
                const categoryChannels = Object.keys(this.channels).filter(channel =>
                    getChannelCategory(channel) === category
                );

                if (categoryChannels.length === 0) {
                    return;
                }

                let statusHtml = '';
                let allSuccess = true;
                let anyFailed = false;
                let anyPending = false;

                categoryChannels.forEach(channel => {
                    const channelStatus = this.channels[channel];
                    const statusClass = channelStatus.status === 'success' ? 'success' :
                        channelStatus.status === 'failed' ? 'error' : 'pending';

                    const channelIcon = {
                        'web': 'ğŸŒ',
                        'email': 'ğŸ“§',
                        'sms': 'ğŸ’¬',
                        'voice': 'ğŸ¤'
                    }[channel] || 'ğŸ“¤';

                    let statusIcon = '';
                    let statusColor = '';

                    if (channelStatus.status === 'success') {
                        statusIcon = 'âœ“';
                        statusColor = '#22c55e';
                    } else if (channelStatus.status === 'failed') {
                        statusIcon = 'âœ—';
                        statusColor = '#ef4444';
                        anyFailed = true;
                        allSuccess = false;
                    } else {
                        statusIcon = '<div style="width: 12px; height: 12px; border: 2px solid #fbbf24; border-top: 2px solid transparent; border-radius: 50%; animation: spin 1s linear infinite; display: inline-block;"></div>';
                        statusColor = '#fbbf24';
                        anyPending = true;
                        allSuccess = false;
                    }

                    statusHtml += `
                        <div class="channel-status ${statusClass}" style="display: inline-flex; align-items: center; gap: 8px; margin-right: 15px; margin-bottom: 8px; padding: 6px 12px; border-radius: 6px; min-width: 200px; max-width: none; width: auto; white-space: nowrap; flex-shrink: 0;">
                            <span style="flex-shrink: 0;">${channelIcon}</span>
                            <span style="white-space: nowrap; flex-shrink: 0;">${getChannelDisplayName(channel)}</span>
                            <div style="font-size: 12px; color: ${statusColor}; display: flex; align-items: center; gap: 4px; white-space: nowrap; flex-shrink: 0;">
                                ${statusIcon}
                                <span style="white-space: nowrap; flex-shrink: 0;">${channelStatus.message}</span>
                            </div>
                            ${channelStatus.error ? `<div style="font-size: 10px; color: #ef4444; margin-left: 8px; white-space: nowrap; flex-shrink: 0;">é”™è¯¯: ${channelStatus.error}</div>` : ''}
                        </div>
                    `;
                });

                // åŒ…è£…æˆæ¨ªå‘æ’åˆ—çš„å®¹å™¨
                const wrappedStatusHtml = `
                    <div style="display: flex; flex-wrap: wrap; gap: 12px; align-items: center; justify-content: flex-start; width: 100%; overflow-x: auto;">
                        ${statusHtml}
                    </div>
                `;

                // æ·»åŠ è¯¥åˆ†ç±»çš„æ€»ä½“çŠ¶æ€
                const overallStatus = anyFailed ? 'failed' : (anyPending ? 'pending' : 'success');
                const overallColor = overallStatus === 'success' ? '#22c55e' :
                    overallStatus === 'failed' ? '#ef4444' : '#fbbf24';

                const successCount = categoryChannels.filter(ch => this.channels[ch].status === 'success').length;
                const failedCount = categoryChannels.filter(ch => this.channels[ch].status === 'failed').length;
                const pendingCount = categoryChannels.filter(ch => this.channels[ch].status === 'pending').length;

                const finalStatusHtml = wrappedStatusHtml + `
                    <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #24315f; font-size: 11px; color: ${overallColor};">
                        çŠ¶æ€: æˆåŠŸ ${successCount}, å¤±è´¥ ${failedCount}, å¤„ç†ä¸­ ${pendingCount}
                    </div>
                `;

                statusContent.innerHTML = finalStatusHtml;
            },

            // åœæ­¢è·Ÿè¸ªï¼ˆä¿ç•™å†å²è®°å½•ï¼‰
            stopTracking: function () {
                // åœ¨åœæ­¢è·Ÿè¸ªå‰ä¿å­˜çŠ¶æ€åˆ°å†å²è®°å½•
                this.saveStatusToHistory();

                this.isTracking = false;
                this.messageType = '';
                this.channels = {};
            },

            // æ¸…é™¤æ‰€æœ‰å†å²è®°å½•ï¼ˆä»…åœ¨éœ€è¦å®Œå…¨é‡ç½®æ—¶ä½¿ç”¨ï¼‰
            clearHistory: function () {
                this.statusHistory = {};
            }
        };

        // éšè—ä¹‹å‰æ¶ˆæ¯ç±»å‹çš„çŠ¶æ€æ˜¾ç¤ºï¼Œå¹¶å°è¯•æ¢å¤å½“å‰ç±»å‹çš„çŠ¶æ€
        function hideStatusForPreviousMessageType() {
            // å¦‚æœå½“å‰æœ‰æ´»è·ƒçš„çŠ¶æ€è·Ÿè¸ªä¸”ä¸æ˜¯å½“å‰æ¶ˆæ¯ç±»å‹ï¼Œåˆ™éšè—çŠ¶æ€
            if (channelStatusTracker.isTracking &&
                channelStatusTracker.messageType !== currentMessageType) {
                // ä¿å­˜å½“å‰çŠ¶æ€åˆ°å†å²è®°å½•
                channelStatusTracker.saveStatusToHistory();
                // éšè—å½“å‰æ˜¾ç¤ºçš„çŠ¶æ€
                hideSendingStatus();
            }

            // å°è¯•æ¢å¤å½“å‰æ¶ˆæ¯ç±»å‹çš„å†å²çŠ¶æ€
            if (currentMessageType) {
                const restored = channelStatusTracker.restoreStatusFromHistory(currentMessageType);
                if (restored) {
                    console.log(`å·²æ¢å¤ ${currentMessageType} çš„å‘é€çŠ¶æ€`);
                }
            }
        }

        // é»˜è®¤å€¼é…ç½®
        const defaultValues = {
            'string': '',
            'int': 1,
            'uint64': 1,
            'float64': 0.0,
            'bool': false,
            '[]string': [],
            '[]uint64': [],
            'object': {}
        };

        // å­—æ®µç‰¹å®šçš„é»˜è®¤å€¼
        const fieldDefaults = {
            'priority': 3,
            'userIds': [12345, 67890],
            'sender': 1,
            'appId': 'demo-app',
            'content': {
                'title': 'ç¤ºä¾‹é€šçŸ¥',
                'body': 'è¿™æ˜¯ä¸€æ¡ç¤ºä¾‹é€šçŸ¥å†…å®¹',
                'type': 'info'
            },
            'receivers': [12345, 67890],
            'type': 'info',
            'title': 'ç¤ºä¾‹æ ‡é¢˜',
            'body': 'è¿™æ˜¯æ¶ˆæ¯æ­£æ–‡å†…å®¹',
            'severity': 'medium',
            'message': 'è¿™æ˜¯ä¸€æ¡ç¤ºä¾‹æ¶ˆæ¯',
            'timestamp': new Date().toISOString(),
            'alertId': 'alert-' + Date.now(),
            'category': 'system',
            'maintenanceId': 'maint-' + Date.now(),
            'description': 'ç³»ç»Ÿç»´æŠ¤æè¿°',
            'startTime': new Date().toISOString(),
            'endTime': new Date(Date.now() + 2 * 60 * 60 * 1000).toISOString(), // 2å°æ—¶å
            'affectedServices': ['api', 'web'],
            'orderId': 'order-' + Date.now(),
            'orderNumber': 'ORD' + Date.now(),
            'status': 'confirmed',
            'previousStatus': 'pending',
            'updateTime': new Date().toISOString(),
            'amount': 99.99,
            'trackingNumber': 'TN' + Date.now(),
            'estimatedDelivery': new Date(Date.now() + 3 * 24 * 60 * 60 * 1000).toISOString(), // 3å¤©å
            'alertType': 'login_attempt',
            'ipAddress': '192.168.1.100',
            'location': 'åŒ—äº¬å¸‚',
            'device': 'Chrome æµè§ˆå™¨',
            'riskLevel': 'low',
            'actionRequired': false,
            'actionUrl': 'https://example.com/security',
            'productId': 'prod-' + Date.now(),
            'productName': 'ç¤ºä¾‹äº§å“',
            'version': '1.0.0',
            'launchDate': new Date().toISOString(),
            'price': 299.99,
            'features': ['åŠŸèƒ½1', 'åŠŸèƒ½2', 'åŠŸèƒ½3'],
            'targetAudience': ['å¼€å‘è€…', 'ä¼ä¸šç”¨æˆ·'],
            'availableRegions': ['ä¸­å›½', 'ç¾å›½', 'æ¬§æ´²'],
            'downloadUrl': 'https://example.com/download',
            'campaignId': 'camp-' + Date.now(),
            'campaignName': 'æ˜¥å­£å¤§ä¿ƒé”€',
            'campaignType': 'discount',
            'discountRate': 0.8,
            'couponCode': 'SPRING2024',
            'minAmount': 100.0,
            'maxDiscount': 50.0,
            'targetProducts': ['äº§å“A', 'äº§å“B'],
            'targetCategories': ['ç”µå­äº§å“', 'æœè£…'],
            'bannerUrl': 'https://example.com/banner.jpg',
            'taskId': 'task-' + Date.now(),
            'taskTitle': 'å®Œæˆé¡¹ç›®æŠ¥å‘Š',
            'taskDescription': 'å®ŒæˆQ4é¡¹ç›®æ€»ç»“æŠ¥å‘Š',
            'dueDate': new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(), // 7å¤©å
            'reminderType': 'deadline_approaching',
            'assignedTo': 'å¼ ä¸‰',
            'assignedBy': 'æå››',
            'projectName': 'ç¤ºä¾‹é¡¹ç›®',
            'urgencyLevel': 'medium',
            'estimatedHours': 8.0,
            'completionPercentage': 30,
            'attachments': ['doc1.pdf', 'doc2.xlsx'],
            'tags': ['é‡è¦', 'ç´§æ€¥'],
            // Alertç›¸å…³å­—æ®µçš„é»˜è®¤å€¼
            'severity': 'medium',
            'source': 'ç³»ç»Ÿç›‘æ§',
            'description': 'ç³»ç»Ÿå‘Šè­¦é€šçŸ¥'
        };

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function () {
            loadMessageFormats();
            setupChannelListeners();
        });

        // åŠ è½½æ¶ˆæ¯æ ¼å¼
        async function loadMessageFormats() {
            try {
                console.log('Loading message formats...');
                const response = await fetch('/dynamic-inbox/message-formats');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const result = await response.json();
                console.log('Raw response:', result);

                // æ ¹æ®æœåŠ¡ç«¯æ—¥å¿—ï¼Œæ•°æ®ç»“æ„åº”è¯¥æ˜¯ç›´æ¥çš„å¯¹è±¡æ ¼å¼
                // æ¯ä¸ªæ¶ˆæ¯ç±»å‹åŒ…å« type å’Œ fields å±æ€§
                let formats = result;

                // å¦‚æœå“åº”è¢«åŒ…è£…åœ¨ data å­—æ®µä¸­
                if (result.data && typeof result.data === 'object') {
                    formats = result.data;
                }

                // éªŒè¯æ ¼å¼æ•°æ®
                if (!formats || typeof formats !== 'object') {
                    throw new Error('æ¶ˆæ¯æ ¼å¼æ•°æ®æ— æ•ˆ');
                }

                console.log('Processing formats:', Object.keys(formats));

                // éªŒè¯å¹¶å¤„ç†æ¯ä¸ªæ ¼å¼
                for (const [typeName, format] of Object.entries(formats)) {
                    console.log(`Processing ${typeName}:`, format);

                    if (!format || typeof format !== 'object') {
                        console.warn(`æ¶ˆæ¯ç±»å‹ ${typeName} çš„æ ¼å¼æ•°æ®æ— æ•ˆ:`, format);
                        continue;
                    }

                    // æ£€æŸ¥å­—æ®µåç§°å¤§å°å†™ - å¯èƒ½æ˜¯ Fieldsï¼ˆå¤§å†™ï¼‰æˆ– fieldsï¼ˆå°å†™ï¼‰
                    if (format.Fields && !format.fields) {
                        console.log(`æ¶ˆæ¯ç±»å‹ ${typeName} ä½¿ç”¨å¤§å†™ Fieldsï¼Œè½¬æ¢ä¸ºå°å†™ fields`);
                        format.fields = format.Fields;
                        delete format.Fields;
                    }

                    // ç¡®ä¿æœ‰ fields å­—æ®µ
                    if (!format.fields) {
                        console.warn(`æ¶ˆæ¯ç±»å‹ ${typeName} ç¼ºå°‘ fields å­—æ®µï¼Œè®¾ç½®ä¸ºç©ºæ•°ç»„`);
                        format.fields = [];
                    } else if (!Array.isArray(format.fields)) {
                        console.warn(`æ¶ˆæ¯ç±»å‹ ${typeName} çš„ fields ä¸æ˜¯æ•°ç»„:`, format.fields);
                        format.fields = [];
                    }

                    console.log(`æ¶ˆæ¯ç±»å‹ ${typeName}: ç±»å‹=${format.type || format.Type}, å­—æ®µæ•°é‡=${format.fields.length}`);

                    // è°ƒè¯•ï¼šæ‰“å°å‰å‡ ä¸ªå­—æ®µ
                    if (format.fields.length > 0) {
                        console.log(`${typeName} çš„å‰3ä¸ªå­—æ®µ:`, format.fields.slice(0, 3).map(f => ({
                            name: f.name || f.Name,
                            type: f.type || f.Type,
                            required: f.required !== undefined ? f.required : f.Required
                        })));
                    }
                }

                messageFormats = formats;
                console.log('Final processed message formats:', messageFormats);
                renderMessageTypes();

                // å¦‚æœæ²¡æœ‰åŠ è½½åˆ°ä»»ä½•æ ¼å¼ï¼Œæ˜¾ç¤ºé”™è¯¯
                if (Object.keys(messageFormats).length === 0) {
                    showMessage('æœªæ‰¾åˆ°ä»»ä½•æ¶ˆæ¯æ ¼å¼é…ç½®', 'warning');
                } else {
                    console.log(`æˆåŠŸåŠ è½½ ${Object.keys(messageFormats).length} ç§æ¶ˆæ¯æ ¼å¼`);
                }
            } catch (error) {
                console.error('Failed to load message formats:', error);
                showMessage('åŠ è½½æ¶ˆæ¯æ ¼å¼å¤±è´¥: ' + error.message, 'error');

                // è®¾ç½®ä¸€ä¸ªç©ºçš„æ ¼å¼å¯¹è±¡ä»¥é˜²æ­¢åç»­é”™è¯¯
                messageFormats = {};
            }
        }

        // æ¸²æŸ“æ¶ˆæ¯ç±»å‹åˆ—è¡¨
        function renderMessageTypes() {
            const container = document.getElementById('messageTypes');
            container.innerHTML = '';

            if (!messageFormats || typeof messageFormats !== 'object') {
                container.innerHTML = '<div style="color: #e03131; padding: 10px;">æ¶ˆæ¯æ ¼å¼åŠ è½½å¤±è´¥</div>';
                return;
            }

            const types = Object.keys(messageFormats);
            if (types.length === 0) {
                container.innerHTML = '<div style="color: #f59f00; padding: 10px;">æš‚æ— å¯ç”¨çš„æ¶ˆæ¯ç±»å‹</div>';
                return;
            }

            types.forEach(type => {
                const button = document.createElement('div');
                button.className = 'type-button';
                button.textContent = type;
                button.onclick = () => selectMessageType(type);
                container.appendChild(button);
            });
        }

        // é€‰æ‹©æ¶ˆæ¯ç±»å‹
        function selectMessageType(type) {
            try {
                console.log('Selecting message type:', type);

                // éªŒè¯æ¶ˆæ¯ç±»å‹
                if (!messageFormats[type]) {
                    throw new Error(`æ¶ˆæ¯ç±»å‹ ${type} ä¸å­˜åœ¨`);
                }

                const format = messageFormats[type];
                console.log('Message format for', type, ':', format);

                // éªŒè¯æ ¼å¼ç»“æ„
                if (!format || typeof format !== 'object') {
                    throw new Error(`æ¶ˆæ¯ç±»å‹ ${type} çš„æ ¼å¼æ•°æ®æ— æ•ˆ`);
                }

                // ç¡®ä¿æœ‰fieldså­—æ®µ
                if (!format.fields) {
                    console.warn(`æ¶ˆæ¯ç±»å‹ ${type} æ²¡æœ‰å­—æ®µå®šä¹‰ï¼Œæ·»åŠ ç©ºå­—æ®µæ•°ç»„`);
                    format.fields = [];
                } else if (!Array.isArray(format.fields)) {
                    console.error(`æ¶ˆæ¯ç±»å‹ ${type} çš„å­—æ®µå®šä¹‰ä¸æ˜¯æ•°ç»„æ ¼å¼:`, typeof format.fields, format.fields);
                    throw new Error(`æ¶ˆæ¯ç±»å‹ ${type} çš„å­—æ®µå®šä¹‰ä¸æ˜¯æ•°ç»„æ ¼å¼`);
                }

                console.log(`æ¶ˆæ¯ç±»å‹ ${type} æœ‰ ${format.fields.length} ä¸ªå­—æ®µ:`, format.fields.map(f => f.name));

                // æ›´æ–°æŒ‰é’®çŠ¶æ€
                document.querySelectorAll('.type-button').forEach(btn => {
                    btn.classList.remove('active');
                });

                // æ‰¾åˆ°å½“å‰ç‚¹å‡»çš„æŒ‰é’®å¹¶æ¿€æ´»
                const buttons = document.querySelectorAll('.type-button');
                buttons.forEach(btn => {
                    if (btn.textContent === type) {
                        btn.classList.add('active');
                    }
                });

                currentMessageType = type;
                document.getElementById('formTitle').textContent = `å‘é€ ${type} æ¶ˆæ¯`;

                // éšè—ä¹‹å‰æ¶ˆæ¯ç±»å‹çš„çŠ¶æ€æ˜¾ç¤º
                hideStatusForPreviousMessageType();

                // æ¸²æŸ“è¡¨å•
                renderMessageForm(format);
                document.getElementById('formActions').style.display = 'flex';

                // æ¸…é™¤ä¹‹å‰çš„é”™è¯¯æ¶ˆæ¯
                hideMessage();

                console.log('Successfully selected message type:', type, 'with', format.fields.length, 'fields');
            } catch (error) {
                console.error('Error selecting message type:', error);
                showMessage('é€‰æ‹©æ¶ˆæ¯ç±»å‹å¤±è´¥: ' + error.message, 'error');
            }
        }

        // æ¸²æŸ“æ¶ˆæ¯è¡¨å•
        function renderMessageForm(format) {
            const container = document.getElementById('formContent');

            try {
                console.log('Rendering form with format:', format);

                if (!format || !format.fields) {
                    throw new Error('æ¶ˆæ¯æ ¼å¼æ— æ•ˆï¼šç¼ºå°‘å­—æ®µå®šä¹‰');
                }

                if (!Array.isArray(format.fields)) {
                    console.error('Fields is not an array:', typeof format.fields, format.fields);
                    throw new Error('æ¶ˆæ¯æ ¼å¼æ— æ•ˆï¼šå­—æ®µå®šä¹‰ä¸æ˜¯æ•°ç»„');
                }

                console.log(`Rendering ${format.fields.length} fields for ${currentMessageType}`);

                if (format.fields.length === 0) {
                    container.innerHTML = '<div style="text-align: center; padding: 40px; color: #f59f00;">è¯¥æ¶ˆæ¯ç±»å‹æ²¡æœ‰å¯é…ç½®çš„å­—æ®µ</div>';
                    return;
                }

                const fieldsContainer = document.createElement('div');
                fieldsContainer.className = 'form-fields';

                format.fields.forEach((field, index) => {
                    try {
                        console.log(`Creating field ${index + 1}/${format.fields.length}:`, field);
                        const fieldGroup = createFieldGroup(field);
                        fieldsContainer.appendChild(fieldGroup);
                    } catch (error) {
                        console.error(`Error creating field ${field.name || field.Name}:`, error);
                        // åˆ›å»ºé”™è¯¯å­—æ®µæ˜¾ç¤º
                        const errorDiv = document.createElement('div');
                        errorDiv.className = 'field-group';
                        errorDiv.innerHTML = `
                            <div style="color: #e03131; padding: 10px; border: 1px solid #e03131; border-radius: 4px;">
                                å­—æ®µ "${field.name || field.Name}" æ¸²æŸ“å¤±è´¥: ${error.message}
                            </div>
                        `;
                        fieldsContainer.appendChild(errorDiv);
                    }
                });

                container.innerHTML = '';
                container.appendChild(fieldsContainer);

                console.log('Successfully rendered form for', currentMessageType, 'with', format.fields.length, 'fields');
            } catch (error) {
                console.error('Error rendering message form:', error);
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #e03131;">
                        <p>è¡¨å•æ¸²æŸ“å¤±è´¥: ${error.message}</p>
                        <button class="btn btn-secondary" onclick="resetForm()">é‡æ–°é€‰æ‹©</button>
                    </div>
                `;
            }
        }

        // åˆ›å»ºå­—æ®µç»„
        function createFieldGroup(field) {
            const group = document.createElement('div');
            group.className = 'field-group';

            // å¤„ç†å­—æ®µå±æ€§å¤§å°å†™é—®é¢˜
            const fieldName = field.name || field.Name;
            const fieldType = field.type || field.Type;
            const fieldRequired = field.required !== undefined ? field.required : field.Required;
            const fieldDescription = field.description || field.Description;

            console.log('Creating field:', fieldName, 'type:', fieldType, 'required:', fieldRequired);

            // æ ‡ç­¾
            const label = document.createElement('div');
            label.className = 'field-label';
            label.innerHTML = `
                ${fieldName}
                ${fieldRequired ? '<span class="required">*</span>' : ''}
            `;
            group.appendChild(label);

            // æè¿°
            if (fieldDescription) {
                const desc = document.createElement('div');
                desc.className = 'field-description';
                desc.textContent = fieldDescription;
                group.appendChild(desc);
            }

            // åˆ›å»ºæ ‡å‡†åŒ–çš„å­—æ®µå¯¹è±¡
            const normalizedField = {
                name: fieldName,
                type: fieldType,
                required: fieldRequired,
                description: fieldDescription
            };

            // è¾“å…¥å­—æ®µ
            const input = createInputField(normalizedField);
            group.appendChild(input);

            return group;
        }

        // åˆ›å»ºè¾“å…¥å­—æ®µ
        function createInputField(field) {
            const fieldName = field.name;
            let defaultValue = fieldDefaults[fieldName] || defaultValues[field.type] || '';

            switch (field.type) {
                case 'string':
                    if (fieldName.toLowerCase().includes('time') || fieldName.toLowerCase().includes('date')) {
                        const input = document.createElement('input');
                        input.type = 'datetime-local';
                        input.className = 'field-input';
                        input.name = fieldName;
                        if (defaultValue) {
                            const date = new Date(defaultValue);
                            input.value = date.toISOString().slice(0, 16);
                        }
                        return input;
                    } else if (fieldName.toLowerCase().includes('url') || fieldName.toLowerCase().includes('link')) {
                        const input = document.createElement('input');
                        input.type = 'url';
                        input.className = 'field-input';
                        input.name = fieldName;
                        input.value = defaultValue;
                        input.placeholder = 'è¯·è¾“å…¥URLåœ°å€';
                        return input;
                    } else if (['message', 'description', 'body', 'content'].includes(fieldName.toLowerCase())) {
                        const textarea = document.createElement('textarea');
                        textarea.className = 'field-input';
                        textarea.name = fieldName;
                        textarea.value = defaultValue;
                        textarea.placeholder = `è¯·è¾“å…¥${field.description || field.name}`;
                        return textarea;
                    } else {
                        const input = document.createElement('input');
                        input.type = 'text';
                        input.className = 'field-input';
                        input.name = fieldName;
                        input.value = defaultValue;
                        input.placeholder = `è¯·è¾“å…¥${field.description || field.name}`;
                        return input;
                    }

                case 'int':
                case 'uint64':
                    const numInput = document.createElement('input');
                    numInput.type = 'number';
                    numInput.className = 'field-input';
                    numInput.name = fieldName;
                    numInput.value = defaultValue;
                    if (field.type === 'uint64') {
                        numInput.min = '0';
                    }
                    return numInput;

                case 'float64':
                    const floatInput = document.createElement('input');
                    floatInput.type = 'number';
                    floatInput.step = '0.01';
                    floatInput.className = 'field-input';
                    floatInput.name = fieldName;
                    floatInput.value = defaultValue;
                    return floatInput;

                case 'bool':
                    const checkboxContainer = document.createElement('div');
                    checkboxContainer.style.display = 'flex';
                    checkboxContainer.style.alignItems = 'center';
                    checkboxContainer.style.gap = '8px';

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.name = fieldName;
                    checkbox.checked = defaultValue;

                    const checkboxLabel = document.createElement('label');
                    checkboxLabel.textContent = defaultValue ? 'æ˜¯' : 'å¦';
                    checkboxLabel.style.cursor = 'pointer';

                    checkbox.onchange = function () {
                        checkboxLabel.textContent = this.checked ? 'æ˜¯' : 'å¦';
                    };

                    checkboxContainer.appendChild(checkbox);
                    checkboxContainer.appendChild(checkboxLabel);
                    return checkboxContainer;

                case '[]string':
                case '[]uint64':
                    return createArrayField(field, defaultValue);

                case '[]object':
                    // ç‰¹æ®Šå¤„ç†é™„ä»¶å­—æ®µ
                    if (fieldName === 'attachments') {
                        return createAttachmentField(field, defaultValue);
                    }
                    return createObjectArrayField(field, defaultValue);

                case 'object':
                    return createObjectField(field, defaultValue);

                default:
                    const defaultInput = document.createElement('input');
                    defaultInput.type = 'text';
                    defaultInput.className = 'field-input';
                    defaultInput.name = fieldName;
                    defaultInput.value = typeof defaultValue === 'object' ? JSON.stringify(defaultValue) : defaultValue;
                    return defaultInput;
            }
        }

        // åˆ›å»ºæ•°ç»„å­—æ®µ
        function createArrayField(field, defaultValue) {
            const container = document.createElement('div');
            container.className = 'array-field';

            const itemsContainer = document.createElement('div');
            itemsContainer.className = 'array-items';

            // æ·»åŠ é»˜è®¤å€¼
            if (Array.isArray(defaultValue) && defaultValue.length > 0) {
                defaultValue.forEach(value => {
                    addArrayItem(itemsContainer, field, value);
                });
            } else {
                // è‡³å°‘æ·»åŠ ä¸€ä¸ªç©ºé¡¹
                addArrayItem(itemsContainer, field, '');
            }

            const addButton = document.createElement('button');
            addButton.type = 'button';
            addButton.className = 'array-add';
            addButton.textContent = '+ æ·»åŠ é¡¹';
            addButton.onclick = () => addArrayItem(itemsContainer, field, '');

            container.appendChild(itemsContainer);
            container.appendChild(addButton);

            // æ·»åŠ éšè—çš„inputç”¨äºè¡¨å•æäº¤
            const hiddenInput = document.createElement('input');
            hiddenInput.type = 'hidden';
            hiddenInput.name = field.name;
            container.appendChild(hiddenInput);

            // æ›´æ–°éšè—å­—æ®µå€¼çš„å‡½æ•°
            const updateHiddenValue = () => {
                const values = Array.from(itemsContainer.children).map(item => {
                    const input = item.querySelector('input');
                    const value = input.value.trim();
                    if (field.type === '[]uint64') {
                        return value ? parseInt(value) : null;
                    }
                    return value;
                }).filter(v => v !== null && v !== '');
                hiddenInput.value = JSON.stringify(values);
            };

            // ç›‘å¬å˜åŒ–
            itemsContainer.addEventListener('input', updateHiddenValue);
            itemsContainer.addEventListener('DOMNodeRemoved', updateHiddenValue);
            itemsContainer.addEventListener('DOMNodeInserted', updateHiddenValue);

            // åˆå§‹åŒ–å€¼
            setTimeout(updateHiddenValue, 0);

            return container;
        }

        // æ·»åŠ æ•°ç»„é¡¹
        function addArrayItem(container, field, value = '') {
            const item = document.createElement('div');
            item.className = 'array-item';

            const input = document.createElement('input');
            input.type = field.type === '[]uint64' ? 'number' : 'text';
            input.className = 'field-input';
            input.value = value;
            input.placeholder = field.type === '[]uint64' ? 'è¯·è¾“å…¥æ•°å­—' : 'è¯·è¾“å…¥æ–‡æœ¬';

            const removeButton = document.createElement('button');
            removeButton.type = 'button';
            removeButton.className = 'array-remove';
            removeButton.textContent = 'åˆ é™¤';
            removeButton.onclick = () => {
                if (container.children.length > 1) {
                    container.removeChild(item);
                } else {
                    input.value = '';
                }
            };

            item.appendChild(input);
            item.appendChild(removeButton);
            container.appendChild(item);
        }

        // åˆ›å»ºå¯¹è±¡å­—æ®µ
        function createObjectField(field, defaultValue) {
            const container = document.createElement('div');
            container.className = 'object-field';

            const textarea = document.createElement('textarea');
            textarea.className = 'field-input';
            textarea.name = field.name;
            textarea.placeholder = 'è¯·è¾“å…¥JSONæ ¼å¼çš„å¯¹è±¡æ•°æ®';

            // è®¾ç½®é»˜è®¤å€¼
            try {
                textarea.value = JSON.stringify(defaultValue, null, 2);
            } catch (e) {
                textarea.value = '{}';
            }

            // æ·»åŠ JSONéªŒè¯
            const validateJSON = () => {
                try {
                    JSON.parse(textarea.value);
                    textarea.style.borderColor = '#24315f';
                    return true;
                } catch (e) {
                    textarea.style.borderColor = '#e03131';
                    return false;
                }
            };

            textarea.addEventListener('blur', validateJSON);
            textarea.addEventListener('input', validateJSON);

            const helpText = document.createElement('div');
            helpText.className = 'help-text';
            helpText.textContent = 'è¯·è¾“å…¥æœ‰æ•ˆçš„JSONæ ¼å¼æ•°æ®ï¼Œä¾‹å¦‚ï¼š{"key": "value", "number": 123}';

            container.appendChild(textarea);
            container.appendChild(helpText);

            return container;
        }

        // åˆ›å»ºå¯¹è±¡æ•°ç»„å­—æ®µ
        function createObjectArrayField(field, defaultValue) {
            const container = document.createElement('div');
            container.className = 'object-array-field';

            const textarea = document.createElement('textarea');
            textarea.className = 'field-input';
            textarea.name = field.name;
            textarea.placeholder = 'è¯·è¾“å…¥JSONæ ¼å¼çš„å¯¹è±¡æ•°ç»„æ•°æ®';

            // è®¾ç½®é»˜è®¤å€¼
            try {
                textarea.value = JSON.stringify(defaultValue || [], null, 2);
            } catch (e) {
                textarea.value = '[]';
            }

            // æ·»åŠ JSONéªŒè¯
            const validateJSON = () => {
                try {
                    const parsed = JSON.parse(textarea.value);
                    if (!Array.isArray(parsed)) {
                        throw new Error('å¿…é¡»æ˜¯æ•°ç»„æ ¼å¼');
                    }
                    textarea.style.borderColor = '#24315f';
                    return true;
                } catch (e) {
                    textarea.style.borderColor = '#e03131';
                    return false;
                }
            };

            textarea.addEventListener('blur', validateJSON);
            textarea.addEventListener('input', validateJSON);

            const helpText = document.createElement('div');
            helpText.className = 'help-text';
            helpText.textContent = 'è¯·è¾“å…¥æœ‰æ•ˆçš„JSONæ ¼å¼æ•°ç»„ï¼Œä¾‹å¦‚ï¼š[{"key": "value"}, {"key": "value2"}]';

            container.appendChild(textarea);
            container.appendChild(helpText);

            return container;
        }

        // åˆ›å»ºé™„ä»¶å­—æ®µï¼ˆæ”¯æŒæ–‡ä»¶ä¸Šä¼ ï¼‰
        function createAttachmentField(field, defaultValue) {
            const container = document.createElement('div');
            container.className = 'attachment-field';

            // åˆ›å»ºæ–‡ä»¶ä¸Šä¼ åŒºåŸŸ
            const uploadArea = document.createElement('div');
            uploadArea.className = 'attachment-upload-area';
            uploadArea.innerHTML = `
                <div class="upload-zone" id="upload-zone-${field.name}">
                    <div class="upload-icon">ğŸ“</div>
                    <div class="upload-text">
                        <p>ç‚¹å‡»é€‰æ‹©æ–‡ä»¶æˆ–æ‹–æ‹½æ–‡ä»¶åˆ°æ­¤å¤„</p>
                        <p class="upload-hint">æ”¯æŒå¤šä¸ªæ–‡ä»¶ä¸Šä¼ ï¼Œæœ€å¤§å•æ–‡ä»¶10MB</p>
                    </div>
                    <input type="file" class="file-input" id="file-input-${field.name}" multiple>
                </div>
            `;

            // æ–‡ä»¶åˆ—è¡¨å®¹å™¨
            const fileList = document.createElement('div');
            fileList.className = 'attachment-list';
            fileList.id = `attachment-list-${field.name}`;

            // éšè—çš„inputç”¨äºå­˜å‚¨é™„ä»¶æ•°æ®
            const hiddenInput = document.createElement('input');
            hiddenInput.type = 'hidden';
            hiddenInput.name = field.name;
            hiddenInput.value = JSON.stringify(defaultValue || []);

            container.appendChild(uploadArea);
            container.appendChild(fileList);
            container.appendChild(hiddenInput);

            // è®¾ç½®æ–‡ä»¶ä¸Šä¼ äº‹ä»¶
            setupFileUpload(field.name, hiddenInput);

            // å¦‚æœæœ‰é»˜è®¤å€¼ï¼Œæ˜¾ç¤ºå·²æœ‰é™„ä»¶
            if (defaultValue && Array.isArray(defaultValue) && defaultValue.length > 0) {
                displayAttachments(field.name, defaultValue);
            }

            return container;
        }

        // è®¾ç½®æ–‡ä»¶ä¸Šä¼ åŠŸèƒ½
        function setupFileUpload(fieldName, hiddenInput) {
            // ä½¿ç”¨ setTimeout ç¡®ä¿å…ƒç´ å·²æ·»åŠ åˆ°DOM
            setTimeout(() => {
                const uploadZone = document.getElementById(`upload-zone-${fieldName}`);
                const fileInput = document.getElementById(`file-input-${fieldName}`);
                const fileList = document.getElementById(`attachment-list-${fieldName}`);

                if (!uploadZone || !fileInput || !fileList) {
                    console.error(`[ATTACHMENT] æ‰¾ä¸åˆ°é™„ä»¶ä¸Šä¼ å…ƒç´ : fieldName=${fieldName}`);
                    return;
                }

                // ç‚¹å‡»ä¸Šä¼ åŒºåŸŸè§¦å‘æ–‡ä»¶é€‰æ‹©
                uploadZone.addEventListener('click', () => {
                    fileInput.click();
                });

                // æ–‡ä»¶é€‰æ‹©å¤„ç†
                fileInput.addEventListener('change', (e) => {
                    handleFileSelect(e.target.files, fieldName, hiddenInput);
                });

                // æ‹–æ‹½ä¸Šä¼ å¤„ç†
                uploadZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadZone.classList.add('drag-over');
                });

                uploadZone.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    uploadZone.classList.remove('drag-over');
                });

                uploadZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadZone.classList.remove('drag-over');
                    handleFileSelect(e.dataTransfer.files, fieldName, hiddenInput);
                });
            }, 100);
        }

        // å¤„ç†æ–‡ä»¶é€‰æ‹©
        async function handleFileSelect(files, fieldName, hiddenInput) {
            const maxFileSize = 10 * 1024 * 1024; // 10MB
            const attachments = JSON.parse(hiddenInput.value || '[]');

            for (let i = 0; i < files.length; i++) {
                const file = files[i];

                // éªŒè¯æ–‡ä»¶å¤§å°
                if (file.size > maxFileSize) {
                    showMessage(`æ–‡ä»¶ "${file.name}" è¶…è¿‡10MBé™åˆ¶`, 'error');
                    continue;
                }

                try {
                    // æ˜¾ç¤ºä¸Šä¼ è¿›åº¦
                    const progressId = `progress-${Date.now()}-${i}`;
                    addUploadProgress(fieldName, file.name, progressId);

                    // ä¸Šä¼ æ–‡ä»¶
                    const uploadResult = await uploadFile(file, progressId);

                    // æ·»åŠ åˆ°é™„ä»¶åˆ—è¡¨
                    const attachment = {
                        fileName: file.name,
                        fileType: file.type || 'application/octet-stream',
                        filePath: uploadResult.filePath,
                        fileSize: file.size,
                        uploadId: uploadResult.uploadId
                    };

                    attachments.push(attachment);

                    // ç§»é™¤è¿›åº¦æ˜¾ç¤ºï¼Œæ·»åŠ é™„ä»¶æ˜¾ç¤º
                    removeUploadProgress(fieldName, progressId);
                    addAttachmentItem(fieldName, attachment, attachments.length - 1);

                } catch (error) {
                    console.error('File upload error:', error);
                    showMessage(`æ–‡ä»¶ "${file.name}" ä¸Šä¼ å¤±è´¥: ${error.message}`, 'error');
                    removeUploadProgress(fieldName, progressId);
                }
            }

            // æ›´æ–°éšè—å­—æ®µ
            hiddenInput.value = JSON.stringify(attachments);

            // æ¸…ç©ºæ–‡ä»¶è¾“å…¥
            document.getElementById(`file-input-${fieldName}`).value = '';
        }

        // æ·»åŠ ä¸Šä¼ è¿›åº¦æ˜¾ç¤º
        function addUploadProgress(fieldName, fileName, progressId) {
            const fileList = document.getElementById(`attachment-list-${fieldName}`);
            const progressItem = document.createElement('div');
            progressItem.className = 'attachment-progress';
            progressItem.id = progressId;
            progressItem.innerHTML = `
                <div class="progress-info">
                    <span class="file-name">${fileName}</span>
                    <span class="progress-status">ä¸Šä¼ ä¸­...</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" style="width: 0%"></div>
                </div>
            `;
            fileList.appendChild(progressItem);
        }

        // æ›´æ–°ä¸Šä¼ è¿›åº¦
        function updateUploadProgress(progressId, percentage) {
            const progressItem = document.getElementById(progressId);
            if (progressItem) {
                const progressFill = progressItem.querySelector('.progress-fill');
                const progressStatus = progressItem.querySelector('.progress-status');
                progressFill.style.width = `${percentage}%`;
                progressStatus.textContent = `ä¸Šä¼ ä¸­... ${percentage}%`;
            }
        }

        // ç§»é™¤ä¸Šä¼ è¿›åº¦æ˜¾ç¤º
        function removeUploadProgress(fieldName, progressId) {
            const progressItem = document.getElementById(progressId);
            if (progressItem) {
                progressItem.remove();
            }
        }

        // ä¸Šä¼ æ–‡ä»¶åˆ°æœåŠ¡å™¨
        async function uploadFile(file, progressId) {
            return new Promise((resolve, reject) => {
                const formData = new FormData();
                formData.append('file', file);

                const xhr = new XMLHttpRequest();

                // ä¸Šä¼ è¿›åº¦ç›‘å¬
                xhr.upload.addEventListener('progress', (e) => {
                    if (e.lengthComputable) {
                        const percentage = Math.round((e.loaded * 100) / e.total);
                        updateUploadProgress(progressId, percentage);
                    }
                });

                // å®Œæˆç›‘å¬
                xhr.addEventListener('load', () => {
                    if (xhr.status === 200) {
                        try {
                            const response = JSON.parse(xhr.responseText);
                            if (response.code === 0) {
                                resolve(response.data);
                            } else {
                                reject(new Error(response.message || 'ä¸Šä¼ å¤±è´¥'));
                            }
                        } catch (e) {
                            reject(new Error('å“åº”è§£æå¤±è´¥'));
                        }
                    } else {
                        reject(new Error(`ä¸Šä¼ å¤±è´¥: HTTP ${xhr.status}`));
                    }
                });

                // é”™è¯¯ç›‘å¬
                xhr.addEventListener('error', () => {
                    reject(new Error('ç½‘ç»œé”™è¯¯'));
                });

                // å‘é€è¯·æ±‚
                xhr.open('POST', '/v1/upload');
                xhr.send(formData);
            });
        }

        // æ˜¾ç¤ºé™„ä»¶åˆ—è¡¨
        function displayAttachments(fieldName, attachments) {
            // ä½¿ç”¨setTimeoutç¡®ä¿DOMå…ƒç´ å·²ç»åˆ›å»º
            setTimeout(() => {
                if (attachments && Array.isArray(attachments)) {
                    attachments.forEach((attachment, index) => {
                        addAttachmentItem(fieldName, attachment, index);
                    });
                }
            }, 100);
        }

        // æ·»åŠ é™„ä»¶é¡¹æ˜¾ç¤º
        function addAttachmentItem(fieldName, attachment, index) {
            const fileList = document.getElementById(`attachment-list-${fieldName}`);
            if (!fileList) {
                console.error(`[ATTACHMENT] æ‰¾ä¸åˆ°é™„ä»¶åˆ—è¡¨å…ƒç´ : attachment-list-${fieldName}`);
                return;
            }

            // éªŒè¯é™„ä»¶å¯¹è±¡
            if (!attachment || typeof attachment !== 'object') {
                console.error(`[ATTACHMENT] æ— æ•ˆçš„é™„ä»¶å¯¹è±¡:`, attachment);
                return;
            }

            const attachmentItem = document.createElement('div');
            attachmentItem.className = 'attachment-item';

            // å®‰å…¨åœ°è·å–é™„ä»¶å±æ€§ï¼Œæä¾›é»˜è®¤å€¼
            const fileName = attachment.fileName || attachment.filename || 'æœªçŸ¥æ–‡ä»¶';
            const fileType = attachment.fileType || attachment.filetype || 'application/octet-stream';
            const fileSize = attachment.fileSize || attachment.size || 0;
            const filePath = attachment.filePath || attachment.path || '';

            attachmentItem.innerHTML = `
                <div class="attachment-info">
                    <div class="file-icon">${getFileIcon(fileType)}</div>
                    <div class="file-details">
                        <div class="file-name">${fileName}</div>
                        <div class="file-meta">
                            ${formatFileSize(fileSize)} â€¢ ${fileType}
                        </div>
                    </div>
                </div>
                <div class="attachment-actions">
                    <button type="button" class="btn-download" onclick="downloadAttachment('${filePath}', '${fileName}')" title="ä¸‹è½½">
                        ğŸ“¥
                    </button>
                    <button type="button" class="btn-remove" onclick="removeAttachment('${fieldName}', ${index})" title="åˆ é™¤">
                        ğŸ—‘ï¸
                    </button>
                </div>
            `;
            fileList.appendChild(attachmentItem);
        }

        // è·å–æ–‡ä»¶å›¾æ ‡
        function getFileIcon(fileType) {
            // é˜²æ­¢fileTypeä¸ºundefinedæˆ–null
            if (!fileType || typeof fileType !== 'string') return 'ğŸ“„';

            if (fileType.startsWith('image/')) return 'ğŸ–¼ï¸';
            if (fileType.startsWith('video/')) return 'ğŸ¥';
            if (fileType.startsWith('audio/')) return 'ğŸµ';
            if (fileType.includes('pdf')) return 'ğŸ“„';
            if (fileType.includes('word')) return 'ğŸ“';
            if (fileType.includes('excel') || fileType.includes('spreadsheet')) return 'ğŸ“Š';
            if (fileType.includes('powerpoint') || fileType.includes('presentation')) return 'ğŸ“½ï¸';
            if (fileType.includes('zip') || fileType.includes('archive')) return 'ğŸ“¦';
            return 'ğŸ“„';
        }

        // æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
        function formatFileSize(bytes) {
            // é˜²æ­¢bytesä¸ºundefinedæˆ–null
            if (bytes === undefined || bytes === null || isNaN(bytes)) return '0 B';
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // ä¸‹è½½é™„ä»¶
        function downloadAttachment(filePath, fileName) {
            const link = document.createElement('a');
            link.href = `/v1/download?path=${encodeURIComponent(filePath)}`;
            link.download = fileName;
            link.click();
        }

        // åˆ é™¤é™„ä»¶
        function removeAttachment(fieldName, index) {
            const hiddenInput = document.querySelector(`input[name="${fieldName}"][type="hidden"]`);
            if (!hiddenInput) {
                console.error(`[ATTACHMENT] æ‰¾ä¸åˆ°éšè—è¾“å…¥å­—æ®µ: ${fieldName}`);
                return;
            }

            const attachments = JSON.parse(hiddenInput.value || '[]');

            // åˆ é™¤æ–‡ä»¶
            if (attachments[index] && attachments[index].filePath) {
                deleteFile(attachments[index].filePath);
            }

            // ä»æ•°ç»„ä¸­ç§»é™¤
            attachments.splice(index, 1);
            hiddenInput.value = JSON.stringify(attachments);

            // é‡æ–°æ¸²æŸ“é™„ä»¶åˆ—è¡¨
            const fileList = document.getElementById(`attachment-list-${fieldName}`);
            if (fileList) {
                fileList.innerHTML = '';
                displayAttachments(fieldName, attachments);
            } else {
                console.error(`[ATTACHMENT] æ‰¾ä¸åˆ°é™„ä»¶åˆ—è¡¨å…ƒç´ : attachment-list-${fieldName}`);
            }
        }

        // åˆ é™¤æœåŠ¡å™¨ä¸Šçš„æ–‡ä»¶
        async function deleteFile(filePath) {
            try {
                const response = await fetch('/v1/delete', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ filePath: filePath })
                });

                if (!response.ok) {
                    console.error('åˆ é™¤æ–‡ä»¶å¤±è´¥:', response.statusText);
                }
            } catch (error) {
                console.error('åˆ é™¤æ–‡ä»¶é”™è¯¯:', error);
            }
        }

        // è®¾ç½®é€šé“ç›‘å¬å™¨
        function setupChannelListeners() {
            document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                if (checkbox.value) {
                    checkbox.addEventListener('change', function () {
                        updateSelectedChannels();
                        updateRecipientsSection();
                    });
                }
            });
            // åˆå§‹åŒ–æ¥æ”¶è€…åŒºåŸŸ
            updateRecipientsSection();
        }

        // æ›´æ–°é€‰ä¸­çš„é€šé“
        function updateSelectedChannels() {
            selectedChannels = Array.from(document.querySelectorAll('input[type="checkbox"]:checked'))
                .map(cb => cb.value)
                .filter(val => val);
        }

        // æ›´æ–°æ¥æ”¶è€…ä¿¡æ¯åŒºåŸŸ
        function updateRecipientsSection() {
            const container = document.getElementById('recipientsSection');
            if (!container) return;

            container.innerHTML = '<h3>æ¥æ”¶è€…é…ç½®</h3>';

            if (selectedChannels.length === 0) {
                container.innerHTML += '<div style="color: #7c8db5; text-align: center; padding: 20px;">è¯·å…ˆé€‰æ‹©å‘é€é€šé“</div>';
                return;
            }

            selectedChannels.forEach(channel => {
                const group = createRecipientGroup(channel);
                container.appendChild(group);
            });
        }

        // åˆ›å»ºæ¥æ”¶è€…è¾“å…¥ç»„
        function createRecipientGroup(channel) {
            const group = document.createElement('div');
            group.className = 'recipient-group';

            const channelConfig = {
                web: {
                    label: 'ç«™å†…ä¿¡æ¥æ”¶è€…',
                    placeholder: 'è¯·è¾“å…¥ç”¨æˆ·IDï¼Œå¤šä¸ªç”¨é€—å·åˆ†éš”ï¼Œå¦‚ï¼š12345,67890',
                    type: 'userIds',
                    icon: 'web',
                    description: 'è¯·è¾“å…¥æ•°å­—å½¢å¼çš„ç”¨æˆ·ID',
                    validate: (value) => {
                        const num = parseInt(value);
                        return !isNaN(num) && num > 0;
                    }
                },
                email: {
                    label: 'é‚®ä»¶æ¥æ”¶è€…',
                    placeholder: 'è¯·è¾“å…¥é‚®ç®±åœ°å€ï¼Œå¤šä¸ªç”¨é€—å·åˆ†éš”ï¼Œå¦‚ï¼šuser1@example.com,user2@example.com',
                    type: 'emails',
                    icon: 'email',
                    description: 'è¯·è¾“å…¥æœ‰æ•ˆçš„é‚®ç®±åœ°å€',
                    validate: (value) => {
                        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                        return emailRegex.test(value);
                    }
                },
                sms: {
                    label: 'çŸ­ä¿¡æ¥æ”¶è€…',
                    placeholder: 'è¯·è¾“å…¥æ‰‹æœºå·ç ï¼Œå¤šä¸ªç”¨é€—å·åˆ†éš”ï¼Œå¦‚ï¼š13800138000,13900139000',
                    type: 'phones',
                    icon: 'sms',
                    description: 'è¯·è¾“å…¥æœ‰æ•ˆçš„æ‰‹æœºå·ç ',
                    validate: (value) => {
                        const phoneRegex = /^1[3-9]\d{9}$/;
                        return phoneRegex.test(value);
                    }
                },
                voice: {
                    label: 'è¯­éŸ³æ¥æ”¶è€…',
                    placeholder: 'è¯·è¾“å…¥ç”µè¯å·ç ï¼Œå¤šä¸ªç”¨é€—å·åˆ†éš”ï¼Œå¦‚ï¼š13800138000,13900139000',
                    type: 'phones',
                    icon: 'voice',
                    description: 'è¯·è¾“å…¥æœ‰æ•ˆçš„ç”µè¯å·ç ',
                    validate: (value) => {
                        const phoneRegex = /^1[3-9]\d{9}$/;
                        return phoneRegex.test(value);
                    }
                }
            };

            const config = channelConfig[channel];
            if (!config) return group;

            // æ ‡ç­¾
            const label = document.createElement('div');
            label.className = 'recipient-channel-label';
            label.innerHTML = `
                <span class="channel-icon ${config.icon}"></span>
                ${config.label}
            `;
            group.appendChild(label);

            // æè¿°
            if (config.description) {
                const desc = document.createElement('div');
                desc.className = 'field-description';
                desc.style.marginBottom = '8px';
                desc.textContent = config.description;
                group.appendChild(desc);
            }

            // è¾“å…¥åŒºåŸŸ
            const inputGroup = document.createElement('div');
            inputGroup.className = 'recipient-input-group';

            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'recipient-input';
            input.placeholder = config.placeholder;
            input.dataset.channel = channel;
            input.dataset.type = config.type;

            // è®¾ç½®é»˜è®¤å€¼
            if (channel === 'web') {
                input.value = '12345,67890';
            } else if (channel === 'email') {
                input.value = 'Lzp15703905620@163.com';
            } else if (channel === 'sms' || channel === 'voice') {
                input.value = '19334199436';
            }

            // æ ‡ç­¾å®¹å™¨
            const tagsContainer = document.createElement('div');
            tagsContainer.className = 'recipient-tags';

            // å¤„ç†è¾“å…¥
            input.addEventListener('input', function () {
                updateRecipientTags(this, tagsContainer, config);
            });

            // å¤„ç†Enteré”®æ·»åŠ æ ‡ç­¾
            input.addEventListener('keydown', function (e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const currentValue = this.value.trim();
                    if (currentValue && !currentValue.endsWith(',')) {
                        this.value = currentValue + ',';
                        updateRecipientTags(this, tagsContainer, config);
                    }
                }
            });

            // åˆå§‹åŒ–æ ‡ç­¾
            updateRecipientTags(input, tagsContainer, config);

            inputGroup.appendChild(input);
            inputGroup.appendChild(tagsContainer);
            group.appendChild(inputGroup);

            // é‚®ä»¶é€šé“æ˜¾ç¤ºé™„ä»¶ä¸Šä¼ åŒºåŸŸï¼ˆå¯é€‰é¡¹ï¼‰
            if (channel === 'email') {
                // åˆ›å»ºé™„ä»¶å­—æ®µï¼Œå­—æ®µåä¸º emailAttachments
                const attachmentField = createAttachmentField({ name: 'emailAttachments' }, []);
                // æ·»åŠ æ ‡é¢˜
                const attachTitle = document.createElement('div');
                attachTitle.className = 'field-description';
                attachTitle.style.margin = '8px 0 4px 0';
                attachTitle.textContent = 'é‚®ä»¶é™„ä»¶ï¼ˆå¯é€‰ï¼‰';
                group.appendChild(attachTitle);
                group.appendChild(attachmentField);
            }

            return group;
        }

        // æ›´æ–°æ¥æ”¶è€…æ ‡ç­¾
        function updateRecipientTags(input, container, config) {
            const values = input.value.split(',').map(v => v.trim()).filter(v => v);
            container.innerHTML = '';

            values.forEach((value, index) => {
                const tag = document.createElement('div');
                tag.className = 'recipient-tag';

                // éªŒè¯å€¼çš„æœ‰æ•ˆæ€§
                const isValid = config && config.validate ? config.validate(value) : true;
                if (!isValid) {
                    tag.classList.add('invalid');
                    tag.style.backgroundColor = 'rgba(224, 49, 49, 0.2)';
                    tag.style.color = '#ff6b6b';
                    tag.style.borderColor = '#ff6b6b';
                }

                tag.innerHTML = `
                    ${value}${!isValid ? ' âš ï¸' : ''}
                    <span class="remove-tag" onclick="removeRecipientTag('${input.dataset.channel}', ${index})">&times;</span>
                `;
                container.appendChild(tag);
            });
        }

        // ç§»é™¤æ¥æ”¶è€…æ ‡ç­¾
        function removeRecipientTag(channel, index) {
            const input = document.querySelector(`input[data-channel="${channel}"]`);
            if (!input) return;

            const values = input.value.split(',').map(v => v.trim()).filter(v => v);
            values.splice(index, 1);
            input.value = values.join(', ');

            const tagsContainer = input.parentElement.querySelector('.recipient-tags');
            const channelConfigs = {
                web: {
                    validate: (value) => !isNaN(parseInt(value)) && parseInt(value) > 0
                },
                email: {
                    validate: (value) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)
                },
                sms: {
                    validate: (value) => /^1[3-9]\d{9}$/.test(value)
                },
                voice: {
                    validate: (value) => /^1[3-9]\d{9}$/.test(value)
                }
            };
            updateRecipientTags(input, tagsContainer, channelConfigs[channel]);
        }        // æ”¶é›†è¡¨å•æ•°æ®
        function collectFormData() {
            if (!currentMessageType) {
                throw new Error('è¯·é€‰æ‹©æ¶ˆæ¯ç±»å‹');
            }

            if (!messageFormats[currentMessageType]) {
                throw new Error('æ¶ˆæ¯æ ¼å¼æ— æ•ˆæˆ–å­—æ®µä¸ºç©º');
            }

            updateSelectedChannels();
            if (selectedChannels.length === 0) {
                throw new Error('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªå‘é€é€šé“');
            }

            const formData = {};
            const format = messageFormats[currentMessageType];

            if (!format.fields || format.fields.length === 0) {
                throw new Error('æ¶ˆæ¯æ ¼å¼æ— æ•ˆæˆ–å­—æ®µä¸ºç©º');
            }

            format.fields.forEach(field => {
                // å¤„ç†å­—æ®µå±æ€§å¤§å°å†™é—®é¢˜
                const fieldName = field.name || field.Name;
                const fieldType = field.type || field.Type;
                const fieldRequired = field.required !== undefined ? field.required : field.Required;

                if (fieldType === '[]string' || fieldType === '[]uint64') {
                    // æ•°ç»„å­—æ®µä»éšè—inputè·å–
                    const hiddenInput = document.querySelector(`input[name="${fieldName}"][type="hidden"]`);
                    if (hiddenInput && hiddenInput.value) {
                        try {
                            formData[fieldName] = JSON.parse(hiddenInput.value);
                        } catch (e) {
                            formData[fieldName] = fieldDefaults[fieldName] || [];
                        }
                    } else {
                        formData[fieldName] = fieldDefaults[fieldName] || [];
                    }
                } else if (fieldType === '[]object') {
                    // å¯¹è±¡æ•°ç»„å­—æ®µï¼ˆåŒ…æ‹¬é™„ä»¶ï¼‰
                    const hiddenInput = document.querySelector(`input[name="${fieldName}"][type="hidden"]`);
                    if (hiddenInput && hiddenInput.value) {
                        try {
                            formData[fieldName] = JSON.parse(hiddenInput.value);
                        } catch (e) {
                            formData[fieldName] = fieldDefaults[fieldName] || [];
                        }
                    } else {
                        // å°è¯•ä»textareaè·å–ï¼ˆå¯¹äºæ™®é€šå¯¹è±¡æ•°ç»„å­—æ®µï¼‰
                        const textarea = document.querySelector(`textarea[name="${fieldName}"]`);
                        if (textarea && textarea.value.trim()) {
                            try {
                                formData[fieldName] = JSON.parse(textarea.value);
                            } catch (e) {
                                throw new Error(`${fieldName} å­—æ®µçš„JSONæ ¼å¼ä¸æ­£ç¡®`);
                            }
                        } else {
                            formData[fieldName] = fieldDefaults[fieldName] || [];
                        }
                    }
                } else if (fieldType === 'object') {
                    // å¯¹è±¡å­—æ®µ
                    const textarea = document.querySelector(`textarea[name="${fieldName}"]`);
                    if (textarea && textarea.value.trim()) {
                        try {
                            formData[fieldName] = JSON.parse(textarea.value);
                        } catch (e) {
                            throw new Error(`${fieldName} å­—æ®µçš„JSONæ ¼å¼ä¸æ­£ç¡®`);
                        }
                    } else {
                        formData[fieldName] = fieldDefaults[fieldName] || {};
                    }
                } else if (fieldType === 'bool') {
                    // å¸ƒå°”å­—æ®µ
                    const checkbox = document.querySelector(`input[name="${fieldName}"][type="checkbox"]`);
                    formData[fieldName] = checkbox ? checkbox.checked : (fieldDefaults[fieldName] || false);
                } else if (fieldType === 'int' || fieldType === 'uint64') {
                    // æ•°å­—å­—æ®µ
                    const input = document.querySelector(`input[name="${fieldName}"]`);
                    if (input && input.value !== '') {
                        formData[fieldName] = parseInt(input.value);
                    } else if (field.required) {
                        throw new Error(`${fieldName} æ˜¯å¿…å¡«å­—æ®µ`);
                    } else {
                        formData[fieldName] = fieldDefaults[fieldName] || (fieldType === 'uint64' ? 1 : 1);
                    }
                } else if (fieldType === 'float64') {
                    // æµ®ç‚¹æ•°å­—æ®µ
                    const input = document.querySelector(`input[name="${fieldName}"]`);
                    if (input && input.value !== '') {
                        formData[fieldName] = parseFloat(input.value);
                    } else if (fieldRequired) {
                        throw new Error(`${fieldName} æ˜¯å¿…å¡«å­—æ®µ`);
                    } else {
                        formData[fieldName] = fieldDefaults[fieldName] || 0.0;
                    }
                } else {
                    // å­—ç¬¦ä¸²å­—æ®µ
                    const input = document.querySelector(`input[name="${fieldName}"], textarea[name="${fieldName}"]`);
                    if (input) {
                        if (input.type === 'datetime-local' && input.value) {
                            formData[fieldName] = new Date(input.value).toISOString();
                        } else {
                            formData[fieldName] = input.value || fieldDefaults[fieldName] || '';
                        }

                        if (fieldRequired && !formData[fieldName]) {
                            throw new Error(`${fieldName} æ˜¯å¿…å¡«å­—æ®µ`);
                        }
                    } else {
                        // å¦‚æœæ‰¾ä¸åˆ°è¾“å…¥å­—æ®µï¼Œä½¿ç”¨é»˜è®¤å€¼
                        formData[fieldName] = fieldDefaults[fieldName] || '';
                        if (fieldRequired && !formData[fieldName]) {
                            throw new Error(`${fieldName} æ˜¯å¿…å¡«å­—æ®µ`);
                        }
                    }
                }
            });

            // æ”¶é›†æ¥æ”¶è€…ä¿¡æ¯å¹¶æ·»åŠ åˆ°formDataä¸­
            const recipients = collectRecipients();

            // æ ¹æ®é€‰æ‹©çš„é€šé“è®¾ç½®æ¥æ”¶è€…ä¿¡æ¯åˆ°formDataä¸­
            if (recipients.userIds && recipients.userIds.length > 0) {
                formData.userIds = recipients.userIds;
            }
            if (recipients.emails && recipients.emails.length > 0) {
                formData.emails = recipients.emails;
            }
            if (recipients.phones && recipients.phones.length > 0) {
                formData.phones = recipients.phones;
            }

            // é‚®ä»¶é€šé“é™„ä»¶ï¼ˆå¯é€‰é¡¹ï¼‰
            if (selectedChannels.includes('email')) {
                const emailAttachInput = document.querySelector('input[name="emailAttachments"][type="hidden"]');
                if (emailAttachInput && emailAttachInput.value) {
                    try {
                        const attachments = JSON.parse(emailAttachInput.value);
                        if (Array.isArray(attachments) && attachments.length > 0) {
                            formData.attachments = attachments; // å…³é”®ï¼šèµ‹å€¼åˆ° attachments å­—æ®µ
                        }
                    } catch (e) {
                        // é™„ä»¶è§£æå¤±è´¥ï¼Œå¿½ç•¥
                    }
                }
            }

            // éªŒè¯æ¯ä¸ªé€šé“éƒ½æœ‰å¯¹åº”çš„æ¥æ”¶è€…
            const channelValidation = validateChannelRecipients(selectedChannels, recipients);
            if (!channelValidation.valid) {
                throw new Error(channelValidation.message);
            }

            return {
                type: currentMessageType,
                data: formData,
                channels: selectedChannels,
                recipients: recipients
            };
        }

        // æ”¶é›†æ¥æ”¶è€…ä¿¡æ¯
        function collectRecipients() {
            const recipients = {
                userIds: [],
                emails: [],
                phones: []
            };

            selectedChannels.forEach(channel => {
                const input = document.querySelector(`input[data-channel="${channel}"]`);
                if (!input || !input.value.trim()) return;

                const values = input.value.split(',').map(v => v.trim()).filter(v => v);

                switch (channel) {
                    case 'web':
                        // ç«™å†…ä¿¡ä½¿ç”¨ç”¨æˆ·IDï¼ˆæ•°å­—ï¼‰
                        recipients.userIds.push(...values.map(v => parseInt(v)).filter(v => !isNaN(v)));
                        break;
                    case 'email':
                        // é‚®ä»¶ä½¿ç”¨é‚®ç®±åœ°å€
                        recipients.emails.push(...values.filter(v => v.includes('@')));
                        break;
                    case 'sms':
                    case 'voice':
                        // çŸ­ä¿¡å’Œè¯­éŸ³ä½¿ç”¨ç”µè¯å·ç 
                        recipients.phones.push(...values.filter(v => /^\d+$/.test(v)));
                        break;
                }
            });

            // å»é‡
            recipients.userIds = [...new Set(recipients.userIds)];
            recipients.emails = [...new Set(recipients.emails)];
            recipients.phones = [...new Set(recipients.phones)];

            return recipients;
        }

        // éªŒè¯é€šé“å’Œæ¥æ”¶è€…åŒ¹é…
        function validateChannelRecipients(channels, recipients) {
            const errors = [];

            for (const channel of channels) {
                switch (channel) {
                    case 'web':
                        if (!recipients.userIds || recipients.userIds.length === 0) {
                            errors.push('ç«™å†…ä¿¡é€šé“éœ€è¦è‡³å°‘ä¸€ä¸ªç”¨æˆ·ID');
                        }
                        break;
                    case 'email':
                        if (!recipients.emails || recipients.emails.length === 0) {
                            errors.push('é‚®ä»¶é€šé“éœ€è¦è‡³å°‘ä¸€ä¸ªé‚®ç®±åœ°å€');
                        }
                        break;
                    case 'sms':
                        if (!recipients.phones || recipients.phones.length === 0) {
                            errors.push('çŸ­ä¿¡é€šé“éœ€è¦è‡³å°‘ä¸€ä¸ªæ‰‹æœºå·ç ');
                        }
                        break;
                    case 'voice':
                        if (!recipients.phones || recipients.phones.length === 0) {
                            errors.push('è¯­éŸ³é€šé“éœ€è¦è‡³å°‘ä¸€ä¸ªç”µè¯å·ç ');
                        }
                        break;
                }
            }

            return {
                valid: errors.length === 0,
                message: errors.length > 0 ? errors.join('ï¼›') : ''
            };
        }

        // é¢„è§ˆæ¶ˆæ¯
        function previewMessage() {
            try {
                const messageData = collectFormData();

                // åˆ›å»ºé¢„è§ˆçª—å£
                const previewWindow = window.open('', '_blank', 'width=800,height=600');
                previewWindow.document.write(`
                    <html>
                    <head>
                        <title>æ¶ˆæ¯é¢„è§ˆ</title>
                        <style>
                            body { 
                                font-family: Arial, sans-serif; 
                                padding: 20px; 
                                background: #f5f5f5; 
                            }
                            .preview-container { 
                                background: white; 
                                padding: 20px; 
                                border-radius: 8px; 
                                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                            }
                            .section { 
                                margin-bottom: 20px; 
                                padding: 15px; 
                                border: 1px solid #e0e0e0; 
                                border-radius: 5px; 
                            }
                            .section-title { 
                                font-weight: bold; 
                                color: #333; 
                                margin-bottom: 10px; 
                            }
                            pre { 
                                background: #f8f8f8; 
                                padding: 10px; 
                                border-radius: 4px; 
                                overflow-x: auto; 
                                font-size: 14px;
                            }
                            .channels { 
                                display: flex; 
                                gap: 10px; 
                            }
                            .channel-tag { 
                                background: #4c6ef5; 
                                color: white; 
                                padding: 4px 8px; 
                                border-radius: 4px; 
                                font-size: 12px; 
                            }
                        </style>
                    </head>
                    <body>
                        <div class="preview-container">
                            <h2>æ¶ˆæ¯é¢„è§ˆ</h2>
                            <div class="section">
                                <div class="section-title">æ¶ˆæ¯ç±»å‹</div>
                                <div>${messageData.type}</div>
                            </div>
                            <div class="section">
                                <div class="section-title">å‘é€é€šé“</div>
                                <div class="channels">
                                    ${messageData.channels.map(ch => `<span class="channel-tag">${ch}</span>`).join('')}
                                </div>
                            </div>
                            <div class="section">
                                <div class="section-title">æ¶ˆæ¯æ•°æ®</div>
                                <pre>${JSON.stringify(messageData.data, null, 2)}</pre>
                            </div>
                        </div>
                    </body>
                    </html>
                `);
                previewWindow.document.close();
            } catch (error) {
                showMessage(error.message, 'error');
            }
        }



        // é€šé“ç±»å‹åˆ†ç±»
        const channelCategories = {
            voice: ['voice'],
            sms: ['sms'],
            general: ['web', 'email'] // é€šç”¨æ¶ˆæ¯é€šé“
        };

        // è·å–é€šé“çš„åˆ†ç±»
        function getChannelCategory(channel) {
            if (channelCategories.voice.includes(channel)) {
                return 'voice';
            }
            if (channelCategories.sms.includes(channel)) {
                return 'sms';
            }
            return 'general';
        }

        // æŒ‰é€šé“åˆ†ç»„



        function groupChannelsByCategory(channels) {
            const groups = {
                voice: [],
                sms: [],
                general: []
            };

            channels.forEach(channel => {
                const category = getChannelCategory(channel);
                groups[category].push(channel);
            });

            return groups;
        }

        // æ˜¾ç¤ºå‘é€çŠ¶æ€ï¼ˆä½¿ç”¨æ–°çš„å®æ—¶çŠ¶æ€ç®¡ç†ï¼‰
        function showSendingStatus(message, channels, messageType = null) {
            const container = document.getElementById('sendingStatusDisplay');

            if (!container || !channels || channels.length === 0) {
                return;
            }

            // å¯åŠ¨çŠ¶æ€è·Ÿè¸ªï¼Œä¼ é€’æ¶ˆæ¯ç±»å‹
            channelStatusTracker.startTracking(channels, messageType);

            // æ˜¾ç¤ºä¸»å®¹å™¨
            container.style.display = 'block';

            // æŒ‰é€šé“ç±»å‹åˆ†ç»„
            const channelGroups = groupChannelsByCategory(channels);

            // ä¸ºæ¯ä¸ªæœ‰é€šé“çš„åˆ†ç±»æ˜¾ç¤ºçŠ¶æ€åŒºåŸŸ
            Object.keys(channelGroups).forEach(category => {
                const categoryChannels = channelGroups[category];
                if (categoryChannels.length > 0) {
                    const statusSection = document.getElementById(`${category}SendingStatus`);

                    if (statusSection) {
                        // æ˜¾ç¤ºå¯¹åº”çš„çŠ¶æ€åŒºåŸŸ
                        statusSection.style.display = 'block';

                        // æ¸²æŸ“åˆå§‹çŠ¶æ€
                        channelStatusTracker.renderCategoryStatus(category);
                    }
                }
            });

            // è®¾ç½®è‡ªåŠ¨å…³é—­å®šæ—¶å™¨
            setAutoCloseTimer();
        }

        // æ›´æ–°å•ä¸ªé€šé“çŠ¶æ€ï¼ˆæ–°çš„å®æ—¶æ›´æ–°æ–¹å¼ï¼‰
        function updateChannelStatus(channel, status, message = '', error = '') {
            if (channelStatusTracker.isTracking) {
                channelStatusTracker.updateChannel(channel, status, message, error);

                // å½“çŠ¶æ€æ›´æ–°æ—¶ï¼Œé‡æ–°è®¾ç½®è‡ªåŠ¨å…³é—­å®šæ—¶å™¨
                setAutoCloseTimer();
            }
        }

        // æ›´æ–°å‘é€çŠ¶æ€ï¼ˆå¤„ç†æœåŠ¡å™¨è¿”å›çš„æ‰¹é‡ç»“æœï¼‰
        function updateSendingStatus(result, messageType = null) {
            console.log('Updating sending status with result:', result);

            if (!result.channel_results || result.channel_results.length === 0) {
                console.log('æ²¡æœ‰å…·ä½“çš„é€šé“ç»“æœï¼Œè·³è¿‡çŠ¶æ€æ›´æ–°');
                return;
            }

            // æ›´æ–°æ¯ä¸ªé€šé“çš„çŠ¶æ€
            result.channel_results.forEach(cr => {
                const message = cr.status === 'success' ? 'å‘é€æˆåŠŸ' :
                    cr.status === 'failed' ? 'å‘é€å¤±è´¥' :
                        cr.status === 'pending' ? 'å¤„ç†ä¸­...' : 'å‘é€å®Œæˆ';

                console.log(`æ›´æ–°é€šé“ ${cr.channel} çŠ¶æ€: ${cr.status} - ${message}`);
                updateChannelStatus(cr.channel, cr.status, message, cr.error || '');
            });
        }

        // éšè—å‘é€çŠ¶æ€ï¼ˆä¸æ–°çš„çŠ¶æ€ç®¡ç†å™¨å…¼å®¹ï¼‰
        function hideSendingStatus(category = null) {
            if (category) {
                // éšè—ç‰¹å®šç±»å‹çš„çŠ¶æ€
                const statusSection = document.getElementById(`${category}SendingStatus`);
                if (statusSection) {
                    statusSection.style.display = 'none';
                }
            } else {
                // éšè—æ‰€æœ‰çŠ¶æ€
                const allCategories = ['general', 'voice', 'sms'];
                allCategories.forEach(cat => {
                    const statusSection = document.getElementById(`${cat}SendingStatus`);
                    if (statusSection) {
                        statusSection.style.display = 'none';
                    }
                });
            }

            // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰çŠ¶æ€éƒ½éšè—äº†ï¼Œå¦‚æœæ˜¯åˆ™éšè—ä¸»å®¹å™¨
            const allSections = ['generalSendingStatus', 'voiceSendingStatus', 'smsSendingStatus'];
            const visibleSections = allSections.filter(id => {
                const section = document.getElementById(id);
                return section && section.style.display !== 'none';
            });

            if (visibleSections.length === 0) {
                const container = document.getElementById('sendingStatusDisplay');
                if (container) {
                    container.style.display = 'none';
                }
                // åœæ­¢çŠ¶æ€è·Ÿè¸ª
                channelStatusTracker.stopTracking();
            }
        }

        // æ¸…é™¤å‘é€çŠ¶æ€ï¼ˆä¸æ–°çš„çŠ¶æ€ç®¡ç†å™¨å…¼å®¹ï¼‰
        function clearSendingStatus(category = null) {
            if (category) {
                // æ¸…é™¤ç‰¹å®šç±»å‹çš„çŠ¶æ€
                const statusContent = document.getElementById(`${category}StatusContent`);
                if (statusContent) {
                    statusContent.innerHTML = '';
                }
                hideSendingStatus(category);
            } else {
                // æ¸…é™¤æ‰€æœ‰çŠ¶æ€
                const allCategories = ['general', 'voice', 'sms'];
                allCategories.forEach(cat => {
                    const statusContent = document.getElementById(`${cat}StatusContent`);
                    if (statusContent) {
                        statusContent.innerHTML = '';
                    }
                });
                hideSendingStatus();
                // åœæ­¢çŠ¶æ€è·Ÿè¸ª
                channelStatusTracker.stopTracking();
            }
        }



        // è·å–å‘é€çŠ¶æ€å®¹å™¨ï¼ˆä¿æŒå…¼å®¹æ€§ï¼‰
        function getSendingStatusContainer() {
            return document.getElementById('sendingStatusDisplay');
        }

        // è‡ªåŠ¨å…³é—­å®šæ—¶å™¨
        let autoCloseTimer = null;

        // æ‰‹åŠ¨å…³é—­å‘é€çŠ¶æ€æ˜¾ç¤º
        function closeSendingStatus() {
            clearSendingStatus();

            // æ¸…é™¤è‡ªåŠ¨å…³é—­å®šæ—¶å™¨
            if (autoCloseTimer) {
                clearTimeout(autoCloseTimer);
                autoCloseTimer = null;
            }
        }

        // è®¾ç½®è‡ªåŠ¨å…³é—­å®šæ—¶å™¨ï¼ˆ5ç§’åè‡ªåŠ¨å…³é—­ï¼‰
        function setAutoCloseTimer() {
            // æ¸…é™¤ä¹‹å‰çš„å®šæ—¶å™¨
            if (autoCloseTimer) {
                clearTimeout(autoCloseTimer);
            }

            autoCloseTimer = setTimeout(() => {
                const container = document.getElementById('sendingStatusDisplay');
                if (container && container.style.display !== 'none') {
                    // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰pendingçŠ¶æ€ï¼Œå¦‚æœæœ‰åˆ™ä¸è‡ªåŠ¨å…³é—­
                    const hasPendingStatus = channelStatusTracker.isTracking &&
                        Object.values(channelStatusTracker.channels).some(ch => ch.status === 'pending');

                    if (!hasPendingStatus) {
                        closeSendingStatus();
                        console.log('çŠ¶æ€æ˜¾ç¤ºå·²è‡ªåŠ¨å…³é—­');
                    } else {
                        // å¦‚æœè¿˜æœ‰pendingçŠ¶æ€ï¼Œå»¶é•¿5ç§’å†æ¬¡æ£€æŸ¥
                        setAutoCloseTimer();
                    }
                }
            }, 5000); // 5ç§’åè‡ªåŠ¨å…³é—­
        }

        // å‘é€æ¶ˆæ¯
        async function sendMessage() {
            try {
                // é¦–å…ˆè¿›è¡Œå®¢æˆ·ç«¯éªŒè¯
                console.log('å¼€å§‹å‘é€æ¶ˆæ¯ï¼Œå½“å‰æ¶ˆæ¯ç±»å‹:', currentMessageType);

                if (!currentMessageType) {
                    throw new Error('è¯·å…ˆé€‰æ‹©æ¶ˆæ¯ç±»å‹');
                }

                // éªŒè¯å¿…å¡«å­—æ®µ
                const format = messageFormats[currentMessageType];
                if (!format || !format.fields) {
                    throw new Error(`æ¶ˆæ¯ç±»å‹ ${currentMessageType} çš„æ ¼å¼é…ç½®æ— æ•ˆ`);
                }

                // æ£€æŸ¥å¿…å¡«å­—æ®µ
                const missingFields = [];
                format.fields.forEach(field => {
                    const fieldName = field.name || field.Name;
                    const fieldRequired = field.required !== undefined ? field.required : field.Required;

                    if (fieldRequired) {
                        const input = document.querySelector(`input[name="${fieldName}"], textarea[name="${fieldName}"]`);
                        const value = input ? input.value.trim() : '';

                        if (!value) {
                            missingFields.push(fieldName);
                        }
                    }
                });

                if (missingFields.length > 0) {
                    throw new Error(`ä»¥ä¸‹å¿…å¡«å­—æ®µæœªå¡«å†™: ${missingFields.join(', ')}`);
                }

                const messageData = collectFormData();

                // æ¸…é™¤ä¹‹å‰çš„çŠ¶æ€å¹¶æ˜¾ç¤ºå‘é€ä¸­çŠ¶æ€
                clearSendingStatus();
                showSendingStatus('æ­£åœ¨å‘é€æ¶ˆæ¯...', messageData.channels, currentMessageType);

                // æ„é€ å‘é€æ•°æ® - æ ¹æ®æ¶ˆæ¯ç±»å‹é€‰æ‹©APIç«¯ç‚¹
                let sendData, endpoint;

                // åŸºç¡€æ¶ˆæ¯ç±»å‹åˆ—è¡¨ï¼ˆä¸åç«¯ä¿æŒä¸€è‡´ï¼‰
                const basicTypes = ['Msg', 'Alert', 'Notification', 'SMSMessage', 'VoiceMessage'];
                const isBasicType = basicTypes.includes(currentMessageType);

                console.log(`æ¶ˆæ¯ç±»å‹ ${currentMessageType} æ˜¯å¦ä¸ºåŸºç¡€ç±»å‹: ${isBasicType}`);

                if (isBasicType) {
                    // åŸºç¡€ç±»å‹ä½¿ç”¨é€šç”¨API endpoint
                    // ä¸ºäº†é¿å…å¹‚ç­‰æ€§æ£€æŸ¥ï¼Œæ·»åŠ å”¯ä¸€æ ‡è¯†ç¬¦
                    const msgDataWithTimestamp = { ...messageData.data };
                    msgDataWithTimestamp._sendTime = new Date().toISOString();
                    msgDataWithTimestamp._requestId = Math.random().toString(36).substr(2, 9);

                    sendData = {
                        topic: currentMessageType,
                        msg: msgDataWithTimestamp,
                        channels: messageData.channels,
                        // æ·»åŠ æ¥æ”¶è€…ä¿¡æ¯
                        userIds: messageData.recipients.userIds,
                        emails: messageData.recipients.emails,
                        phones: messageData.recipients.phones
                    };
                    endpoint = '/v1/push';
                    console.log('ä½¿ç”¨é€šç”¨APIç«¯ç‚¹:', endpoint);
                } else {
                    // è‡ªå®šä¹‰ç±»å‹ä½¿ç”¨åŠ¨æ€æ¶ˆæ¯API - å°†é€šé“å’Œæ¥æ”¶è€…ä¿¡æ¯æ·»åŠ åˆ°æ¶ˆæ¯æ•°æ®ä¸­
                    const msgData = { ...messageData.data };
                    // ä¸ºäº†é¿å…å¹‚ç­‰æ€§æ£€æŸ¥ï¼Œæ·»åŠ å”¯ä¸€æ ‡è¯†ç¬¦ï¼ˆä½¿ç”¨ä¸‹åˆ’çº¿å‰ç¼€é¿å…ä¸æ¶ˆæ¯å­—æ®µå†²çªï¼‰
                    msgData._sendTime = new Date().toISOString();
                    msgData._requestId = Math.random().toString(36).substr(2, 9);
                    msgData.channels = messageData.channels;

                    // æ·»åŠ æ¥æ”¶è€…ä¿¡æ¯åˆ°æ¶ˆæ¯æ•°æ®ä¸­
                    if (messageData.recipients.userIds.length > 0) {
                        msgData.userIds = messageData.recipients.userIds;
                    }
                    if (messageData.recipients.emails.length > 0) {
                        msgData.emails = messageData.recipients.emails;
                    }
                    if (messageData.recipients.phones.length > 0) {
                        msgData.phones = messageData.recipients.phones;
                    }

                    sendData = msgData;
                    endpoint = `/v1/push/${currentMessageType}`;
                    console.log('ä½¿ç”¨åŠ¨æ€APIç«¯ç‚¹:', endpoint);
                }

                console.log('Sending message data:', sendData);
                console.log('Using endpoint:', endpoint);

                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(sendData)
                });

                if (response.ok) {
                    const result = await response.json();
                    console.log('Send result:', result);

                    // é¦–å…ˆä¸ºæ‰€æœ‰é€šé“è®¾ç½®åˆå§‹çŠ¶æ€ï¼ˆå¦‚æœåç«¯æ²¡æœ‰è¿”å›å…·ä½“çš„é€šé“ç»“æœï¼‰
                    if (!result.channel_results || result.channel_results.length === 0) {
                        console.log('åç«¯æœªè¿”å›è¯¦ç»†é€šé“ç»“æœï¼Œè®¾ç½®é»˜è®¤çŠ¶æ€');
                        // ä¸ºæ¯ä¸ªé€šé“è®¾ç½®é»˜è®¤çŠ¶æ€
                        messageData.channels.forEach(channel => {
                            if (channel === 'sms' || channel === 'voice') {
                                // SMSå’Œè¯­éŸ³è®¾ç½®ä¸ºpendingï¼Œç­‰å¾…è½®è¯¢æ›´æ–°
                                updateChannelStatus(channel, 'pending', 'æ­£åœ¨å¤„ç†...', '');
                            } else {
                                // webå’Œemailç›´æ¥è®¾ç½®ä¸ºæˆåŠŸ
                                updateChannelStatus(channel, 'success', 'å‘é€æˆåŠŸ', '');
                            }
                        });
                    } else {
                        // æ›´æ–°å‘é€çŠ¶æ€ï¼ˆæŒ‰é€šé“ç±»å‹åˆ†ç¦»ï¼‰
                        updateSendingStatus(result, currentMessageType);
                    }

                    // æ ¹æ®é€šé“ç±»å‹æ˜¾ç¤ºä¸åŒçš„é€šçŸ¥
                    const channelGroups = groupChannelsByCategory(messageData.channels);
                    const hasVoice = channelGroups.voice.length > 0;
                    const hasSMS = channelGroups.sms.length > 0;

                    let messagePrefix = 'æ¶ˆæ¯';
                    if (hasVoice && hasSMS) {
                        messagePrefix = 'ğŸ¤è¯­éŸ³çŸ­ä¿¡æ¶ˆæ¯';
                    } else if (hasVoice) {
                        messagePrefix = 'ğŸ¤ è¯­éŸ³æ¶ˆæ¯';
                    } else if (hasSMS) {
                        messagePrefix = 'ğŸ’¬ çŸ­ä¿¡æ¶ˆæ¯';
                    }

                    // æ˜¾ç¤ºè¯¦ç»†çš„å‘é€ç»“æœ
                    if (result.channel_messages && result.channel_messages.length > 0) {
                        // æ˜¾ç¤ºæ¯ä¸ªé€šé“çš„å‘é€ç»“æœ
                        const channelResults = result.channel_messages.join('<br>');
                        const overallStatus = result.overall_status;

                        if (overallStatus === 'success') {
                            showMessage(`${messagePrefix}å‘é€æˆåŠŸï¼<br>${channelResults}`, 'success');
                        } else if (overallStatus === 'partial') {
                            showMessage(`${messagePrefix}éƒ¨åˆ†å‘é€æˆåŠŸï¼š<br>${channelResults}`, 'warning');
                        } else if (overallStatus === 'failed') {
                            showMessage(`${messagePrefix}å‘é€å¤±è´¥ï¼š<br>${channelResults}`, 'error');
                        } else {
                            showMessage(`${messagePrefix}å‘é€ä¸­ï¼š<br>${channelResults}`, 'info');
                        }

                        // å¦‚æœæœ‰è¯­éŸ³æˆ–çŸ­ä¿¡é€šé“ï¼Œæ˜¾ç¤ºç‰¹æ®Šæç¤º
                        if (hasVoice || hasSMS) {
                            const actions = [];
                            if (hasVoice) actions.push('æ‹¨æ‰“ç”µè¯');
                            if (hasSMS) actions.push('å‘é€çŸ­ä¿¡');
                            const actionText = actions.join('å’Œ');

                            if (overallStatus !== 'failed') {
                                setTimeout(() => {
                                    showMessage(`${actionText}ä»»åŠ¡å·²åŠ å…¥4Gæ¨¡å—é˜Ÿåˆ—ï¼Œè¯·ç­‰å¾…å¤„ç†å®Œæˆ`, 'info');
                                }, 2000);
                            }
                        }
                    } else {
                        // å›é€€åˆ°ç®€å•æ¶ˆæ¯ï¼Œä½†ä¹Ÿè¦åŒ…å«é€šé“ä¿¡æ¯
                        const channelNames = messageData.channels.map(c => getChannelDisplayName(c)).join('ã€');
                        showMessage(`${messagePrefix}é€šè¿‡${channelNames}å‘é€æˆåŠŸï¼`, 'success');
                    }

                    // æ— è®ºæ˜¯å¦æœ‰è¯¦ç»†ç»“æœï¼Œéƒ½è¦å¯åŠ¨SMSå’Œè¯­éŸ³çš„çŠ¶æ€è½®è¯¢
                    if (hasVoice || hasSMS) {
                        console.log('å¯åŠ¨SMS/è¯­éŸ³çŠ¶æ€è½®è¯¢');
                        statusPoller.startPolling(messageData.channels);
                    }

                    // å‘é€æˆåŠŸï¼Œä¸è‡ªåŠ¨é‡ç½®è¡¨å•ï¼Œä¿æŒçŠ¶æ€æ˜¾ç¤º
                    // ç”¨æˆ·å¯ä»¥æ‰‹åŠ¨ç‚¹å‡»é‡ç½®æŒ‰é’®æ¥æ¸…é™¤è¡¨å•
                } else {
                    const error = await response.text();
                    throw new Error(`å‘é€å¤±è´¥: ${error}`);
                }
            } catch (error) {
                console.error('Send error:', error);

                // ä¸éšè—çŠ¶æ€ï¼Œè€Œæ˜¯æ ‡è®°ä¸ºå¤±è´¥
                const messageData = collectFormData();
                messageData.channels.forEach(channel => {
                    updateChannelStatus(channel, 'failed', 'å‘é€å¤±è´¥', error.message);
                });

                showMessage('å‘é€å¤±è´¥: ' + error.message, 'error');
            }
        }

        // ä¿å­˜è‰ç¨¿
        function saveDraft() {
            try {
                const messageData = collectFormData();
                localStorage.setItem('message_draft', JSON.stringify(messageData));
                showMessage('è‰ç¨¿å·²ä¿å­˜', 'success');
            } catch (error) {
                console.error('Save draft error:', error);
                showMessage('ä¿å­˜è‰ç¨¿å¤±è´¥: ' + error.message, 'error');
            }
        }

        // åŠ è½½è‰ç¨¿
        function loadDraft() {
            try {
                const draft = localStorage.getItem('message_draft');
                if (draft) {
                    const messageData = JSON.parse(draft);
                    // TODO: å®ç°è‰ç¨¿åŠ è½½é€»è¾‘
                    showMessage('è‰ç¨¿å·²åŠ è½½', 'success');
                } else {
                    showMessage('æ²¡æœ‰æ‰¾åˆ°è‰ç¨¿', 'info');
                }
            } catch (error) {
                console.error('Load draft error:', error);
                showMessage('åŠ è½½è‰ç¨¿å¤±è´¥: ' + error.message, 'error');
            }
        }

        // æ˜¾ç¤ºæ¶ˆæ¯é€šçŸ¥
        function showMessage(message, type = 'info') {
            const messageDisplay = document.getElementById('messageDisplay');
            if (!messageDisplay) return;

            const typeColors = {
                'success': '#22c55e',
                'error': '#ef4444',
                'warning': '#f59f00',
                'info': '#4c6ef5'
            };

            const typeIcons = {
                'success': 'âœ“',
                'error': 'âœ—',
                'warning': 'âš ',
                'info': 'â„¹'
            };

            messageDisplay.innerHTML = `
                <div style="background: ${typeColors[type] || '#4c6ef5'}; color: white; padding: 12px; border-radius: 6px; margin: 10px 0; display: flex; align-items: center; gap: 8px;">
                    <span style="font-weight: bold;">${typeIcons[type] || 'â„¹'}</span>
                    <span>${message}</span>
                </div>
            `;
            messageDisplay.style.display = 'block';

            // è‡ªåŠ¨éšè—é€šçŸ¥
            setTimeout(() => {
                if (messageDisplay) {
                    messageDisplay.style.display = 'none';
                }
            }, 5000);
        }

        // éšè—æ¶ˆæ¯é€šçŸ¥
        function hideMessage() {
            const messageDisplay = document.getElementById('messageDisplay');
            if (messageDisplay) {
                messageDisplay.style.display = 'none';
                messageDisplay.innerHTML = '';
            }
        }

        // è·å–é€šé“æ˜¾ç¤ºåç§°
        function getChannelDisplayName(channel) {
            const names = {
                'web': 'ç«™å†…ä¿¡',
                'email': 'é‚®ä»¶',
                'sms': 'çŸ­ä¿¡',
                'voice': 'è¯­éŸ³'
            };
            return names[channel] || channel;
        }

        // æŒ‰ç±»åˆ«åˆ†ç»„é€šé“
        function groupChannelsByCategory(channels) {
            const groups = {
                general: [],
                voice: [],
                sms: []
            };

            channels.forEach(channel => {
                if (channel === 'voice') {
                    groups.voice.push(channel);
                } else if (channel === 'sms') {
                    groups.sms.push(channel);
                } else {
                    groups.general.push(channel);
                }
            });

            return groups;
        }

        // æ˜¾ç¤ºé€šé“è¿›åº¦
        function showChannelProgress(channelResults) {
            console.log('Channel progress:', channelResults);
            // è¿™é‡Œå¯ä»¥æ·»åŠ æ›´è¯¦ç»†çš„è¿›åº¦æ˜¾ç¤ºé€»è¾‘
        }

        // çŠ¶æ€è½®è¯¢ç®¡ç†å™¨
        class StatusPoller {
            constructor() {
                this.polling = false;
                this.intervalId = null;
                this.pollInterval = 3000; // 3ç§’è½®è¯¢ä¸€æ¬¡
                this.pendingChannels = new Set();
            }

            // å¼€å§‹è½®è¯¢pendingçŠ¶æ€
            startPolling(channels) {
                if (this.polling) {
                    console.log('[STATUS_POLLER] è½®è¯¢å·²åœ¨è¿›è¡Œä¸­');
                    return;
                }

                // åªè½®è¯¢smså’Œvoiceé€šé“
                const slowChannels = channels.filter(ch => ch === 'sms' || ch === 'voice');
                if (slowChannels.length === 0) {
                    console.log('[STATUS_POLLER] æ²¡æœ‰éœ€è¦è½®è¯¢çš„æ…¢é€Ÿé€šé“');
                    return;
                }

                this.pendingChannels = new Set(slowChannels);
                this.polling = true;
                this.pollCount = 0; // æ·»åŠ è½®è¯¢è®¡æ•°å™¨
                this.maxPollCount = 40; // æœ€å¤§è½®è¯¢æ¬¡æ•° (40 * 3ç§’ = 2åˆ†é’Ÿ)

                console.log('[STATUS_POLLER] å¼€å§‹è½®è¯¢çŠ¶æ€:', slowChannels);

                this.intervalId = setInterval(() => {
                    this.pollCount++;
                    console.log(`[STATUS_POLLER] ç¬¬ ${this.pollCount} æ¬¡è½®è¯¢`);

                    // å¦‚æœè½®è¯¢æ¬¡æ•°è¶…è¿‡æœ€å¤§å€¼ï¼Œå¼ºåˆ¶å®Œæˆ
                    if (this.pollCount >= this.maxPollCount) {
                        console.log('[STATUS_POLLER] è½®è¯¢è¶…æ—¶ï¼Œå¼ºåˆ¶å®Œæˆ');
                        this.forceComplete();
                        return;
                    }

                    this.pollPendingStatuses();
                }, this.pollInterval);

                // æœ€å¤šè½®è¯¢2åˆ†é’Ÿ
                setTimeout(() => {
                    if (this.polling) {
                        console.log('[STATUS_POLLER] è½®è¯¢è¶…æ—¶ï¼Œåœæ­¢è½®è¯¢');
                        this.forceComplete();
                    }
                }, 120000);
            }

            // å¼ºåˆ¶å®Œæˆå¤„ç†
            forceComplete() {
                console.log('[STATUS_POLLER] å¼ºåˆ¶å®Œæˆæ‰€æœ‰pendingé€šé“');
                const channelUpdates = {};

                for (const channel of this.pendingChannels) {
                    // è®¾ç½®ä¸ºæˆåŠŸçŠ¶æ€ï¼ˆå‡è®¾é•¿æ—¶é—´æ— å“åº”è¡¨ç¤ºå¤„ç†å®Œæˆï¼‰
                    updateChannelStatus(channel, 'success', 'å¤„ç†å®Œæˆ', '');
                    channelUpdates[channel] = 'success';
                }

                // æ˜¾ç¤ºå®Œæˆé€šçŸ¥
                if (Object.keys(channelUpdates).length > 0) {
                    const messages = [];
                    for (const [channel] of Object.entries(channelUpdates)) {
                        const channelName = getChannelDisplayName(channel);
                        messages.push(`${channelName}å¤„ç†å®Œæˆ`);
                    }
                    showMessage(messages.join('ï¼Œ'), 'success');
                }

                this.stopPolling();
            }

            // åœæ­¢è½®è¯¢
            stopPolling() {
                if (this.intervalId) {
                    clearInterval(this.intervalId);
                    this.intervalId = null;
                }
                this.polling = false;
                this.pendingChannels.clear();
                console.log('[STATUS_POLLER] åœæ­¢çŠ¶æ€è½®è¯¢');
            }            // è½®è¯¢å¾…å¤„ç†çŠ¶æ€
            async pollPendingStatuses() {
                if (this.pendingChannels.size === 0) {
                    this.stopPolling();
                    return;
                }

                const channels = Array.from(this.pendingChannels).join(',');
                console.log('[STATUS_POLLER] è½®è¯¢é€šé“çŠ¶æ€:', channels);

                try {
                    // é¦–å…ˆå°è¯•è½®è¯¢æ¶ˆæ¯çŠ¶æ€
                    const response = await fetch(`/v1/status?channels=${channels}`);
                    console.log('[STATUS_POLLER] çŠ¶æ€æŸ¥è¯¢å“åº”:', response.status);

                    if (response.ok) {
                        const result = await response.json();
                        console.log('[STATUS_POLLER] çŠ¶æ€æŸ¥è¯¢ç»“æœ:', result);

                        if (result.code === 0 && result.data) {
                            // æ£€æŸ¥æ˜¯å¦æœ‰çŠ¶æ€æ•°æ®
                            if (result.data.statuses && result.data.statuses.length > 0) {
                                this.processPendingStatuses(result.data.statuses);
                                return;
                            } else {
                                // å¦‚æœæ²¡æœ‰æ‰¾åˆ°çŠ¶æ€è®°å½•ï¼Œè¯´æ˜å¯èƒ½æ¶ˆæ¯å·²ç»å¤„ç†å®Œæˆ
                                // å¯¹äºçŸ­ä¿¡å’Œè¯­éŸ³ï¼Œå¦‚æœæ²¡æœ‰æ‰¾åˆ°pendingçŠ¶æ€ï¼Œå¯èƒ½æ„å‘³ç€å·²ç»å®Œæˆ
                                console.log('[STATUS_POLLER] æœªæ‰¾åˆ°pendingçŠ¶æ€ï¼Œå¯èƒ½å·²å®Œæˆå¤„ç†');
                                this.handleNoStatusFound();
                                return;
                            }
                        }
                    } else {
                        console.error('[STATUS_POLLER] çŠ¶æ€æŸ¥è¯¢å¤±è´¥:', response.status, response.statusText);
                    }
                } catch (error) {
                    console.error('[STATUS_POLLER] è½®è¯¢æ¶ˆæ¯çŠ¶æ€å¤±è´¥:', error);
                }

                // å¤‡ç”¨æ–¹æ¡ˆï¼šè½®è¯¢4Gæ¨¡å—çŠ¶æ€
                try {
                    const modemResponse = await fetch('/v1/modem/status');
                    if (modemResponse.ok) {
                        const modemResult = await modemResponse.json();
                        console.log('[STATUS_POLLER] 4Gæ¨¡å—çŠ¶æ€:', modemResult);
                        if (modemResult.code === 0) {
                            this.processModemStatus(modemResult.data);
                        }
                    }
                } catch (error) {
                    console.error('[STATUS_POLLER] è½®è¯¢4Gæ¨¡å—çŠ¶æ€å¤±è´¥:', error);
                }
            }

            // å¤„ç†æ²¡æœ‰æ‰¾åˆ°çŠ¶æ€è®°å½•çš„æƒ…å†µ
            handleNoStatusFound() {
                // å¯¹äºé•¿æ—¶é—´æ²¡æœ‰çŠ¶æ€æ›´æ–°çš„æƒ…å†µï¼Œå‡è®¾å¤„ç†æˆåŠŸ
                // è¿™é€šå¸¸å‘ç”Ÿåœ¨æ¶ˆæ¯å·²ç»è¢«å¤„ç†ä½†çŠ¶æ€è®°å½•å·²è¢«æ¸…ç†çš„æƒ…å†µ
                const now = Date.now();
                const channelUpdates = {};

                for (const channel of this.pendingChannels) {
                    // å‡è®¾å¤„ç†æˆåŠŸï¼ˆåœ¨å®é™…åº”ç”¨ä¸­ï¼Œå¯èƒ½éœ€è¦æ›´å¤æ‚çš„é€»è¾‘ï¼‰
                    updateChannelStatus(channel, 'success', 'å‘é€å®Œæˆ', '');
                    channelUpdates[channel] = 'success';
                }

                // æ˜¾ç¤ºå®Œæˆé€šçŸ¥
                if (Object.keys(channelUpdates).length > 0) {
                    const messages = [];
                    for (const [channel, status] of Object.entries(channelUpdates)) {
                        const channelName = getChannelDisplayName(channel);
                        messages.push(`${channelName}å‘é€å®Œæˆ`);
                    }
                    showMessage(messages.join('ï¼Œ'), 'success');
                }

                // åœæ­¢è½®è¯¢
                this.stopPolling();
            }

            // å¤„ç†å¾…å¤„ç†çŠ¶æ€
            processPendingStatuses(statuses) {
                console.log('[STATUS_POLLER] å¤„ç†çŠ¶æ€æ›´æ–°:', statuses);
                const channelUpdates = {};

                statuses.forEach(status => {
                    const channel = status.channel;
                    console.log(`[STATUS_POLLER] å¤„ç†é€šé“ ${channel} çŠ¶æ€: ${status.status}`);

                    // å¦‚æœçŠ¶æ€ä¸å†æ˜¯pendingï¼Œæ›´æ–°å‰ç«¯æ˜¾ç¤º
                    if (status.status !== 'pending') {
                        const statusText = status.status === 'success' ? 'å‘é€æˆåŠŸ' :
                            status.status === 'failed' ? 'å‘é€å¤±è´¥' : 'å¤„ç†å®Œæˆ';

                        updateChannelStatus(channel, status.status, statusText, status.error || '');

                        // ä»å¾…è½®è¯¢åˆ—è¡¨ä¸­ç§»é™¤
                        this.pendingChannels.delete(channel);

                        channelUpdates[channel] = status.status;
                        console.log(`[STATUS_POLLER] é€šé“ ${channel} çŠ¶æ€æ›´æ–°ä¸º: ${status.status}`);
                    } else {
                        // ä»ç„¶æ˜¯pendingçŠ¶æ€ï¼Œæ›´æ–°æ¶ˆæ¯ä½†ä¿æŒåœ¨è½®è¯¢åˆ—è¡¨ä¸­
                        const pendingMessage = status.message || 'å¤„ç†ä¸­...';
                        updateChannelStatus(channel, 'pending', pendingMessage, '');
                        console.log(`[STATUS_POLLER] é€šé“ ${channel} ä»åœ¨å¤„ç†ä¸­: ${pendingMessage}`);
                    }
                });

                // æ˜¾ç¤ºæ›´æ–°é€šçŸ¥
                if (Object.keys(channelUpdates).length > 0) {
                    const messages = [];
                    for (const [channel, status] of Object.entries(channelUpdates)) {
                        const channelName = getChannelDisplayName(channel);
                        const statusText = status === 'success' ? 'å‘é€æˆåŠŸ' :
                            status === 'failed' ? 'å‘é€å¤±è´¥' : 'å¤„ç†å®Œæˆ';
                        messages.push(`${channelName}${statusText}`);
                    }

                    const notificationType = Object.values(channelUpdates).every(s => s === 'success') ? 'success' : 'warning';
                    showMessage(messages.join('ï¼Œ'), notificationType);
                }

                // å¦‚æœæ‰€æœ‰é€šé“éƒ½å®Œæˆäº†ï¼Œåœæ­¢è½®è¯¢
                if (this.pendingChannels.size === 0) {
                    console.log('[STATUS_POLLER] æ‰€æœ‰é€šé“å¤„ç†å®Œæˆï¼Œåœæ­¢è½®è¯¢');
                    this.stopPolling();
                }
            }

            // å¤„ç†4Gæ¨¡å—çŠ¶æ€
            processModemStatus(modemData) {
                // å¦‚æœ4Gæ¨¡å—ä¸å¯ç”¨ï¼Œå°†æ‰€æœ‰pendingçš„sms/voiceæ ‡è®°ä¸ºå¤±è´¥
                if (!modemData.available) {
                    const channelUpdates = {};

                    if (this.pendingChannels.has('sms')) {
                        updateChannelStatus('sms', 'failed', 'å‘é€å¤±è´¥', '4Gæ¨¡å—ä¸å¯ç”¨æˆ–åˆå§‹åŒ–å¤±è´¥');
                        channelUpdates['sms'] = 'failed';
                        this.pendingChannels.delete('sms');
                    }

                    if (this.pendingChannels.has('voice')) {
                        updateChannelStatus('voice', 'failed', 'å‘é€å¤±è´¥', '4Gæ¨¡å—ä¸å¯ç”¨æˆ–åˆå§‹åŒ–å¤±è´¥');
                        channelUpdates['voice'] = 'failed';
                        this.pendingChannels.delete('voice');
                    }

                    // æ˜¾ç¤ºå¤±è´¥é€šçŸ¥
                    if (Object.keys(channelUpdates).length > 0) {
                        const messages = [];
                        for (const [channel] of Object.entries(channelUpdates)) {
                            const channelName = getChannelDisplayName(channel);
                            messages.push(`${channelName}å‘é€å¤±è´¥`);
                        }
                        showMessage(messages.join('ï¼Œ') + 'ï¼š4Gæ¨¡å—ä¸å¯ç”¨', 'error');
                    }

                    // å¦‚æœæ‰€æœ‰é€šé“éƒ½å¤„ç†å®Œäº†ï¼Œåœæ­¢è½®è¯¢
                    if (this.pendingChannels.size === 0) {
                        this.stopPolling();
                    }
                }
            }
        }

        // åˆ›å»ºçŠ¶æ€è½®è¯¢å®ä¾‹
        const statusPoller = new StatusPoller();
    </script>
</body>

</html>